{
  "api/RegexBuilder.CommonPatterns.html": {
    "href": "api/RegexBuilder.CommonPatterns.html",
    "title": "Class CommonPatterns | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class CommonPatterns Namespace RegexBuilder Assembly RegexBuilder.dll Provides factory methods for commonly used regex patterns. public static class CommonPatterns Inheritance object CommonPatterns Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Email() Returns a RegexNode that matches a basic email address pattern. Pattern matches: localpart@domain.tld Local part: alphanumeric characters, dots, hyphens, underscores, percent, and plus signs Domain: alphanumeric characters and hyphens, separated by dots TLD: 2-6 alphabetic characters public static RegexNode Email() Returns RegexNode A RegexNode representing an email address pattern. Examples var regex = RegexBuilder.Build(CommonPatterns.Email()); bool isValid = regex.IsMatch(\"user@example.com\"); // true Url() Returns a RegexNode that matches a URL pattern. Pattern matches URLs with optional protocol, domain, and path. Protocol: http://, https://, or ftp:// (optional) Domain: standard domain format with optional port Path: optional path, query string, and fragment public static RegexNode Url() Returns RegexNode A RegexNode representing a URL pattern. Examples var regex = RegexBuilder.Build(CommonPatterns.Url()); bool isValid = regex.IsMatch(\"https://example.com/path\"); // true"
  },
  "api/RegexBuilder.ExtensionMethods.html": {
    "href": "api/RegexBuilder.ExtensionMethods.html",
    "title": "Class ExtensionMethods | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class ExtensionMethods Namespace RegexBuilder Assembly RegexBuilder.dll public static class ExtensionMethods Inheritance object ExtensionMethods Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ReplaceMany(StringBuilder, string[], string[]) public static void ReplaceMany(this StringBuilder builder, string[] oldValues, string[] newValues) Parameters builder StringBuilder oldValues string[] newValues string[]"
  },
  "api/RegexBuilder.PatternBuilder.html": {
    "href": "api/RegexBuilder.PatternBuilder.html",
    "title": "Class PatternBuilder | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class PatternBuilder Namespace RegexBuilder Assembly RegexBuilder.dll Provides a fluent API for building complex regex patterns with method chaining. public class PatternBuilder Inheritance object PatternBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PatternBuilder() Initializes a new instance of the PatternBuilder class. public PatternBuilder() Methods AnyCharacter(int?, int?) Adds any character pattern (.) with optional quantifiers. public PatternBuilder AnyCharacter(int? min = null, int? max = null) Parameters min int? Minimum number of any characters (null for exactly one). max int? Maximum number of any characters (null for exactly min, or unbounded if min is set). Returns PatternBuilder The current PatternBuilder instance for method chaining. Build() Builds and returns the final RegexNode representing the complete pattern. public RegexNode Build() Returns RegexNode A RegexNode representing the built pattern, or null if no pattern was defined. CharacterSet(string, int?, int?) Adds a character set pattern with optional quantifiers. public PatternBuilder CharacterSet(string characterSet, int? min = null, int? max = null) Parameters characterSet string The character set definition (e.g., \"0-9a-f\" for hex digits). min int? Minimum occurrences (null for exactly one). max int? Maximum occurrences (null for exactly min, or unbounded if min is set). Returns PatternBuilder The current PatternBuilder instance for method chaining. Digits(int?, int?) Adds a digit pattern (\\d) with optional quantifiers. public PatternBuilder Digits(int? min = null, int? max = null) Parameters min int? Minimum number of digits (null for exactly one). max int? Maximum number of digits (null for exactly min, or unbounded if min is set). Returns PatternBuilder The current PatternBuilder instance for method chaining. Email() Adds the common email pattern to the builder. public PatternBuilder Email() Returns PatternBuilder The current PatternBuilder instance for method chaining. End() Adds an end-of-line anchor ($) to the pattern. public PatternBuilder End() Returns PatternBuilder The current PatternBuilder instance for method chaining. Group(Action<PatternBuilder>) Adds a capturing group to the pattern using a builder action. public PatternBuilder Group(Action<PatternBuilder> builderAction) Parameters builderAction Action<PatternBuilder> Action that defines the group's content. Returns PatternBuilder The current PatternBuilder instance for method chaining. Letters(int?, int?) Adds a letter pattern ([a-zA-Z]) with optional quantifiers. public PatternBuilder Letters(int? min = null, int? max = null) Parameters min int? Minimum number of letters (null for exactly one). max int? Maximum number of letters (null for exactly min, or unbounded if min is set). Returns PatternBuilder The current PatternBuilder instance for method chaining. Literal(string) Adds a literal string to the pattern. public PatternBuilder Literal(string text) Parameters text string The literal text to match. Returns PatternBuilder The current PatternBuilder instance for method chaining. NonCapturingGroup(Action<PatternBuilder>) Adds a non-capturing group to the pattern using a builder action. public PatternBuilder NonCapturingGroup(Action<PatternBuilder> builderAction) Parameters builderAction Action<PatternBuilder> Action that defines the group's content. Returns PatternBuilder The current PatternBuilder instance for method chaining. Optional(Action<PatternBuilder>) Makes the previous pattern optional (adds ? quantifier). public PatternBuilder Optional(Action<PatternBuilder> builderAction) Parameters builderAction Action<PatternBuilder> Action that defines the optional content. Returns PatternBuilder The current PatternBuilder instance for method chaining. Or(RegexNode) Adds an alternation (OR) pattern using an existing RegexNode. public PatternBuilder Or(RegexNode node) Parameters node RegexNode The alternative pattern node. Returns PatternBuilder The current PatternBuilder instance for method chaining. Or(Action<PatternBuilder>) Adds an alternation (OR) pattern using a builder action. public PatternBuilder Or(Action<PatternBuilder> builderAction) Parameters builderAction Action<PatternBuilder> Action that defines the alternative branch. Returns PatternBuilder The current PatternBuilder instance for method chaining. Pattern(RegexNode) Adds an existing RegexNode to the pattern. public PatternBuilder Pattern(RegexNode node) Parameters node RegexNode The RegexNode to add. Returns PatternBuilder The current PatternBuilder instance for method chaining. Start() Adds a start-of-line anchor (^) to the pattern. public PatternBuilder Start() Returns PatternBuilder The current PatternBuilder instance for method chaining. Url() Adds the common URL pattern to the builder. public PatternBuilder Url() Returns PatternBuilder The current PatternBuilder instance for method chaining. Whitespace(int?, int?) Adds a whitespace pattern (\\s) with optional quantifiers. public PatternBuilder Whitespace(int? min = null, int? max = null) Parameters min int? Minimum number of whitespace characters (null for exactly one). max int? Maximum number of whitespace characters (null for exactly min, or unbounded if min is set). Returns PatternBuilder The current PatternBuilder instance for method chaining. WordCharacter(int?, int?) Adds a word character pattern (\\w) with optional quantifiers. public PatternBuilder WordCharacter(int? min = null, int? max = null) Parameters min int? Minimum number of word characters (null for exactly one). max int? Maximum number of word characters (null for exactly min, or unbounded if min is set). Returns PatternBuilder The current PatternBuilder instance for method chaining."
  },
  "api/RegexBuilder.RegexBuilder.html": {
    "href": "api/RegexBuilder.RegexBuilder.html",
    "title": "Class RegexBuilder | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexBuilder Namespace RegexBuilder Assembly RegexBuilder.dll public static class RegexBuilder Inheritance object RegexBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Alternate(RegexNode, RegexNode) Generates an alternation expression with two options (\"a|b\"). public static RegexNodeAlternation Alternate(RegexNode expression1, RegexNode expression2) Parameters expression1 RegexNode First option. expression2 RegexNode Second option. Returns RegexNodeAlternation An instance of RegexNode containing the alternation expression. Alternate(RegexNode, RegexNode, RegexQuantifier) Generates an alternation expression with two options (\"a|b\"). public static RegexNodeAlternation Alternate(RegexNode expression1, RegexNode expression2, RegexQuantifier quantifier) Parameters expression1 RegexNode First option. expression2 RegexNode Second option. quantifier RegexQuantifier Node quantifier. Returns RegexNodeAlternation An instance of RegexNode containing the alternation expression. Alternate(RegexNode[]) Generates an alternation expression with two or more options (\"a|b|c|...\"). public static RegexNodeAlternation Alternate(RegexNode[] expressions) Parameters expressions RegexNode[] Array of option expressions. Returns RegexNodeAlternation An instance of RegexNode containing the alternation expression. Alternate(RegexNode[], RegexQuantifier) Generates an alternation expression with two or more options (\"a|b|c|...\"). public static RegexNodeAlternation Alternate(RegexNode[] expressions, RegexQuantifier quantifier) Parameters expressions RegexNode[] Array of option expressions. quantifier RegexQuantifier Node quantifier. Returns RegexNodeAlternation An instance of RegexNode containing the alternation expression. AsciiCharacter(byte) Generates an ASCII character pattern (\"\\xNN\") with the specified character code. public static RegexNodeLiteral AsciiCharacter(byte code) Parameters code byte ASCII character code. Returns RegexNodeLiteral An instance of RegexNode containing the specified ASCII character. AsciiCharacter(byte, RegexQuantifier) Generates an ASCII character pattern (\"\\xNN\") with the specified character code. public static RegexNodeLiteral AsciiCharacter(byte code, RegexQuantifier quantifier) Parameters code byte ASCII character code. quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the specified ASCII character. BacktrackingSuppression(RegexNode) Generates a subexpression with disabled backtracking (\"(?>expression)\"). public static RegexNodeBacktrackingSuppression BacktrackingSuppression(RegexNode innerExpression) Parameters innerExpression RegexNode Inner expression. Returns RegexNodeBacktrackingSuppression An instance of RegexNode containing the expression with suppressed backtracking. BacktrackingSuppression(RegexNode, RegexQuantifier) Generates a subexpression with disabled backtracking (\"(?>expression)\"). public static RegexNodeBacktrackingSuppression BacktrackingSuppression(RegexNode innerExpression, RegexQuantifier quantifier) Parameters innerExpression RegexNode Inner expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeBacktrackingSuppression An instance of RegexNode containing the expression with suppressed backtracking. BalancingGroup(string, string, RegexNode) Generates a balancing group that pushes to one named stack and pops from another. Used for matching nested/balanced constructs like parentheses, XML tags, or code blocks. Syntax: (?<name1-name2>expr) public static RegexNodeBalancingGroup BalancingGroup(string pushGroupName, string popGroupName, RegexNode innerExpression) Parameters pushGroupName string Name of group to push matched text onto. popGroupName string Name of group to pop from stack. innerExpression RegexNode The inner expression to match. Returns RegexNodeBalancingGroup An instance of RegexNode containing the balancing group. BalancingGroup(string, string, RegexNode, RegexQuantifier) Generates a balancing group that pushes to one named stack and pops from another, with a quantifier. Used for matching nested/balanced constructs like parentheses, XML tags, or code blocks. Syntax: (?<name1-name2>expr) public static RegexNodeBalancingGroup BalancingGroup(string pushGroupName, string popGroupName, RegexNode innerExpression, RegexQuantifier quantifier) Parameters pushGroupName string Name of group to push matched text onto. popGroupName string Name of group to pop from stack. innerExpression RegexNode The inner expression to match. quantifier RegexQuantifier Node quantifier. Returns RegexNodeBalancingGroup An instance of RegexNode containing the balancing group. BellCharacter() Generates a bell character (alert) escape sequence (\"\\a\", ASCII 7). public static RegexNodeLiteral BellCharacter() Returns RegexNodeLiteral An instance of RegexNode containing the bell character escape. BellCharacter(RegexQuantifier) Generates a bell character (alert) escape sequence (\"\\a\", ASCII 7) with a quantifier. public static RegexNodeLiteral BellCharacter(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the bell character escape. Build(RegexNode) Generates a Regex object from a single RegexNode. public static Regex Build(RegexNode rootNode) Parameters rootNode RegexNode Root node. Returns Regex A new instance of Regex which corresponds to the specified RegexNode. Build(params RegexNode[]) Generates a Regex object from a list of RegexNodes. public static Regex Build(params RegexNode[] regexNodes) Parameters regexNodes RegexNode[] Top-level nodes for the Regex. Returns Regex A new instance of Regex which corresponds to the specified RegexNode list. Build(RegexOptions, RegexNode) Generates a Regex object from a single RegexNode and applies a combination of RegexOptions to it. public static Regex Build(RegexOptions regexOptions, RegexNode rootNode) Parameters regexOptions RegexOptions Combination of RegexOption flags to be applied to the Regex. rootNode RegexNode Root node. Returns Regex A new instance of Regex which corresponds to the specified RegexNode. Build(RegexOptions, params RegexNode[]) Generates a Regex object from a list of RegexNode and applies a combination of RegexOptions to it. public static Regex Build(RegexOptions regexOptions, params RegexNode[] regexNodes) Parameters regexOptions RegexOptions Combination of RegexOption flags to be applied to the Regex. regexNodes RegexNode[] Top-level nodes for the Regex. Returns Regex A new instance of Regex which corresponds to the specified RegexNode list. CharacterRange(char, char, bool, RegexQuantifier) Generates a character range expression (\"[a-z]\") with the specified start/end characters. public static RegexNodeCharacterRange CharacterRange(char rangeStart, char rangeEnd, bool useCharacterCodes, RegexQuantifier quantifier) Parameters rangeStart char First character in the range. rangeEnd char Last character in the range. useCharacterCodes bool True - encode every character with \"\\uNNNN\" pattern. False - use every character explicitly. quantifier RegexQuantifier Node quantifier. Returns RegexNodeCharacterRange An instance of RegexNode containing the character range. CharacterSet(char[], bool, RegexQuantifier) Generates a character set expression (\"[abc]\") from the specified character array. public static RegexNodeCharacterSet CharacterSet(char[] characters, bool useCharacterCodes, RegexQuantifier quantifier) Parameters characters char[] An array of allowed characters. useCharacterCodes bool True - encode every character with \"\\uNNNN\" pattern. False - use every character explicitly. quantifier RegexQuantifier Node quantifier. Returns RegexNodeCharacterSet CharacterSet(string, RegexQuantifier) Generates a character set expression (\"[abc]\") using a preformatted character string. public static RegexNodeCharacterSet CharacterSet(string characters, RegexQuantifier quantifier) Parameters characters string Character set description. Special characters will be automatically escaped. quantifier RegexQuantifier Node quantifier. Returns RegexNodeCharacterSet An instance of RegexNode containing the character set. Comment(string) Generates an inline Regex comment (\"(?#text)\"). public static RegexNodeComment Comment(string commentText) Parameters commentText string Comment text. Returns RegexNodeComment An instance of RegexNode containing the specified comment. Concatenate(RegexNode, RegexNode) Concatenates two nodes. public static RegexNodeConcatenation Concatenate(RegexNode node1, RegexNode node2) Parameters node1 RegexNode First node. node2 RegexNode Second node. Returns RegexNodeConcatenation An instance of RegexNode representing the concatenation of child nodes. Concatenate(RegexNode, RegexNode, RegexNode) Concatenates three nodes. public static RegexNodeConcatenation Concatenate(RegexNode node1, RegexNode node2, RegexNode node3) Parameters node1 RegexNode First node. node2 RegexNode Second node. node3 RegexNode Third node. Returns RegexNodeConcatenation An instance of RegexNode representing the concatenation of child nodes. Concatenate(RegexNode, RegexNode, RegexNode, RegexNode) Concatenates four nodes. public static RegexNodeConcatenation Concatenate(RegexNode node1, RegexNode node2, RegexNode node3, RegexNode node4) Parameters node1 RegexNode First node. node2 RegexNode Second node. node3 RegexNode Third node. node4 RegexNode Fourth node. Returns RegexNodeConcatenation An instance of RegexNode representing the concatenation of child nodes. Concatenate(RegexNode, RegexNode, RegexNode, RegexNode, RegexQuantifier) Concatenates four nodes. public static RegexNodeConcatenation Concatenate(RegexNode node1, RegexNode node2, RegexNode node3, RegexNode node4, RegexQuantifier quantifier) Parameters node1 RegexNode First node. node2 RegexNode Second node. node3 RegexNode Third node. node4 RegexNode Fourth node. quantifier RegexQuantifier Node quantifier. Returns RegexNodeConcatenation An instance of RegexNode representing the concatenation of child nodes. Concatenate(RegexNode, RegexNode, RegexNode, RegexQuantifier) Concatenates three nodes. public static RegexNodeConcatenation Concatenate(RegexNode node1, RegexNode node2, RegexNode node3, RegexQuantifier quantifier) Parameters node1 RegexNode First node. node2 RegexNode Second node. node3 RegexNode Third node. quantifier RegexQuantifier Node quantifier. Returns RegexNodeConcatenation An instance of RegexNode representing the concatenation of child nodes. Concatenate(RegexNode, RegexNode, RegexQuantifier) Concatenates two nodes. public static RegexNodeConcatenation Concatenate(RegexNode node1, RegexNode node2, RegexQuantifier quantifier) Parameters node1 RegexNode First node. node2 RegexNode Second node. quantifier RegexQuantifier Node quantifier. Returns RegexNodeConcatenation An instance of RegexNode representing the concatenation of child nodes. Concatenate(RegexNode[]) Concatenates an array of nodes. public static RegexNodeConcatenation Concatenate(RegexNode[] expressions) Parameters expressions RegexNode[] Nodes to concatenate. Returns RegexNodeConcatenation An instance of RegexNode representing the concatenation of child nodes. Concatenate(RegexNode[], RegexQuantifier) Concatenates an array of nodes. public static RegexNodeConcatenation Concatenate(RegexNode[] expressions, RegexQuantifier quantifier) Parameters expressions RegexNode[] Nodes to concatenate. quantifier RegexQuantifier Node quantifier. Returns RegexNodeConcatenation An instance of RegexNode representing the concatenation of child nodes. ConditionalMatch(RegexNode, RegexNode, RegexNode) Generates a conditional match expression (\"(?(condition)|(true)|(false))\"). public static RegexNodeConditionalMatch ConditionalMatch(RegexNode conditionExpression, RegexNode trueMatchExpression, RegexNode falseMatchExpression) Parameters conditionExpression RegexNode Condition expression. trueMatchExpression RegexNode True match expression. falseMatchExpression RegexNode False match expression. Returns RegexNodeConditionalMatch An instance of RegexNode containing the conditional match expression. ConditionalMatch(RegexNode, RegexNode, RegexNode, RegexQuantifier) Generates a conditional match expression (\"(?(condition)|(true)|(false))\"). public static RegexNodeConditionalMatch ConditionalMatch(RegexNode conditionExpression, RegexNode trueMatchExpression, RegexNode falseMatchExpression, RegexQuantifier quantifier) Parameters conditionExpression RegexNode Condition expression. trueMatchExpression RegexNode True match expression. falseMatchExpression RegexNode False match expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeConditionalMatch An instance of RegexNode containing the conditional match expression. ConditionalMatch(string, RegexNode, RegexNode) Generates a conditional match expression which uses a named group for condition evaluation (\"(?(GroupName)|(true)|(false))\"). public static RegexNodeConditionalMatch ConditionalMatch(string conditionGroupName, RegexNode trueMatchExpression, RegexNode falseMatchExpression) Parameters conditionGroupName string The name of the group to be used as a condition. trueMatchExpression RegexNode True match expression. falseMatchExpression RegexNode False match expression. Returns RegexNodeConditionalMatch An instance of RegexNode containing the conditional match expression. ConditionalMatch(string, RegexNode, RegexNode, RegexQuantifier) Generates a conditional match expression which uses a named group for condition evaluation (\"(?(GroupName)|(true)|(false))\"). public static RegexNodeConditionalMatch ConditionalMatch(string conditionGroupName, RegexNode trueMatchExpression, RegexNode falseMatchExpression, RegexQuantifier quantifier) Parameters conditionGroupName string The name of the group to be used as a condition. trueMatchExpression RegexNode True match expression. falseMatchExpression RegexNode False match expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeConditionalMatch An instance of RegexNode containing the conditional match expression. Digit() Generates a digit character class (\"\\d\"). public static RegexNodeLiteral Digit() Returns RegexNodeLiteral An instance of RegexNode containing the digit character class. Digit(RegexQuantifier) Generates a digit character class (\"\\d\") with a quantifier. public static RegexNodeLiteral Digit(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the digit character class. EscapeCharacter() Generates an escape character escape sequence (\"\\e\", ASCII 27). public static RegexNodeLiteral EscapeCharacter() Returns RegexNodeLiteral An instance of RegexNode containing the escape character escape. EscapeCharacter(RegexQuantifier) Generates an escape character escape sequence (\"\\e\", ASCII 27) with a quantifier. public static RegexNodeLiteral EscapeCharacter(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the escape character escape. FormFeed() Generates a form feed character escape sequence (\"\\f\", ASCII 12). public static RegexNodeLiteral FormFeed() Returns RegexNodeLiteral An instance of RegexNode containing the form feed character escape. FormFeed(RegexQuantifier) Generates a form feed character escape sequence (\"\\f\", ASCII 12) with a quantifier. public static RegexNodeLiteral FormFeed(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the form feed character escape. Group(RegexNode) Generates an unnamed capturing group with the specified subexpression. public static RegexNodeGroup Group(RegexNode matchExpression) Parameters matchExpression RegexNode Inner expression. Returns RegexNodeGroup An instance of RegexNode containing the unnamed capturing group. Group(RegexNode, RegexQuantifier) Generates an unnamed capturing group with the specified subexpression. public static RegexNodeGroup Group(RegexNode matchExpression, RegexQuantifier quantifier) Parameters matchExpression RegexNode Inner expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeGroup An instance of RegexNode containing the unnamed capturing group. Group(string, RegexNode) Generates a named capturing group with the specified subexpression. public static RegexNodeGroup Group(string groupName, RegexNode matchExpression) Parameters groupName string Group name. matchExpression RegexNode Inner expression. Returns RegexNodeGroup An instance of RegexNode containing the named capturing group. Group(string, RegexNode, RegexQuantifier) Generates a named capturing group with the specified subexpression. public static RegexNodeGroup Group(string groupName, RegexNode matchExpression, RegexQuantifier quantifier) Parameters groupName string Group name. matchExpression RegexNode Inner expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeGroup An instance of RegexNode containing the named capturing group. GroupApostrophe(string, RegexNode) Generates a named capturing group using apostrophe syntax for VBScript compatibility. Syntax: (?'name'expr) public static RegexNodeGroup GroupApostrophe(string groupName, RegexNode matchExpression) Parameters groupName string Group name. matchExpression RegexNode Inner expression. Returns RegexNodeGroup An instance of RegexNode containing the named capturing group with apostrophe syntax. GroupApostrophe(string, RegexNode, RegexQuantifier) Generates a named capturing group using apostrophe syntax for VBScript compatibility. Syntax: (?'name'expr) public static RegexNodeGroup GroupApostrophe(string groupName, RegexNode matchExpression, RegexQuantifier quantifier) Parameters groupName string Group name. matchExpression RegexNode Inner expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeGroup An instance of RegexNode containing the named capturing group with apostrophe syntax. GroupBackReference(int, RegexQuantifier) Generates a backreference to the group with the specified index (\"\\N\"). public static RegexNodeGroupReference GroupBackReference(int groupIndex, RegexQuantifier quantifier) Parameters groupIndex int Group ordinal number. quantifier RegexQuantifier Node quantifier. Returns RegexNodeGroupReference An instance of RegexNode containing the group reference. GroupBackReference(string) Generates a backreference to a named group (\"\\k<GroupName>\"). public static RegexNodeGroupReference GroupBackReference(string groupName) Parameters groupName string Group name. Returns RegexNodeGroupReference An instance of RegexNode containing the group reference. GroupBackReference(string, RegexQuantifier) Generates a backreference to a named group (\"\\k<GroupName>\"). public static RegexNodeGroupReference GroupBackReference(string groupName, RegexQuantifier quantifier) Parameters groupName string Group name. quantifier RegexQuantifier Node quantifier. Returns RegexNodeGroupReference An instance of RegexNode containing the group reference. InlineOptionGrouping(RegexOptions, RegexNode) Generates an inline option grouping with enabled options (\"(?i:expr)\", \"(?im:expr)\", etc.). public static RegexNodeInlineOptionGrouping InlineOptionGrouping(RegexOptions enabledOptions, RegexNode expression) Parameters enabledOptions RegexOptions Options to enable for the expression. expression RegexNode Inner expression. Returns RegexNodeInlineOptionGrouping An instance of RegexNode containing the inline option grouping. InlineOptionGrouping(RegexOptions, RegexOptions, RegexNode) Generates an inline option grouping with enabled and disabled options (\"(?i-m:expr)\", etc.). public static RegexNodeInlineOptionGrouping InlineOptionGrouping(RegexOptions enabledOptions, RegexOptions disabledOptions, RegexNode expression) Parameters enabledOptions RegexOptions Options to enable for the expression. disabledOptions RegexOptions Options to disable for the expression. expression RegexNode Inner expression. Returns RegexNodeInlineOptionGrouping An instance of RegexNode containing the inline option grouping. LineEnd() Generates a line end anchor (\"$\"). public static RegexNodeLiteral LineEnd() Returns RegexNodeLiteral An instance of RegexNode containing the line end anchor. LineStart() Generates a line start anchor (\"^\"). public static RegexNodeLiteral LineStart() Returns RegexNodeLiteral An instance of RegexNode containing the line start anchor. Literal(string) Generates a simple string literal with automatic character escaping. public static RegexNodeEscapingLiteral Literal(string value) Parameters value string Node text. Special characters will be automatically escaped. Returns RegexNodeEscapingLiteral An instance of RegexNode containing the specified text. Literal(string, RegexQuantifier) Generates a simple string literal with automatic character escaping. public static RegexNodeEscapingLiteral Literal(string value, RegexQuantifier quantifier) Parameters value string Node text. Special characters will be automatically escaped. quantifier RegexQuantifier Node quantifier. Returns RegexNodeEscapingLiteral An instance of RegexNode containing the specified text. MatchPointAnchor() Generates a match point anchor (\"\\G\"), which matches at the position of the previous match. public static RegexNodeLiteral MatchPointAnchor() Returns RegexNodeLiteral An instance of RegexNode containing the match point anchor. MetaCharacter(string) Generates a Regex metacharacter, such as \\d, \\w or \\s. Many metacharacter constants are available in RegexMetaChars class. public static RegexNodeLiteral MetaCharacter(string characterPattern) Parameters characterPattern string Metacharacter pattern. Returns RegexNodeLiteral An instance of RegexNode containing the specified metacharacter. MetaCharacter(string, RegexQuantifier) Generates a Regex metacharacter, such as \\d, \\w or \\s. Many metacharacter constants are available in RegexMetaChars class. public static RegexNodeLiteral MetaCharacter(string characterPattern, RegexQuantifier quantifier) Parameters characterPattern string Metacharacter pattern. quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the specified metacharacter. NegativeCharacterRange(char, char, bool, RegexQuantifier) Generates a negative character range expression (\"[^a-z]\") with the specified start/end characters. public static RegexNodeCharacterRange NegativeCharacterRange(char rangeStart, char rangeEnd, bool useCharacterCodes, RegexQuantifier quantifier) Parameters rangeStart char First character in the range. rangeEnd char Last character in the range. useCharacterCodes bool True - encode every character with \"\\uNNNN\" pattern. False - use every character explicitly. quantifier RegexQuantifier Node quantifier. Returns RegexNodeCharacterRange An instance of RegexNode containing the character range. NegativeCharacterSet(char[], bool, RegexQuantifier) Generates a negative character set expression (\"[^abc]\") from the specified character array. public static RegexNodeCharacterSet NegativeCharacterSet(char[] characters, bool useCharacterCodes, RegexQuantifier quantifier) Parameters characters char[] An array of allowed characters. useCharacterCodes bool True - encode every character with \"\\uNNNN\" pattern. False - use every character explicitly. quantifier RegexQuantifier Node quantifier. Returns RegexNodeCharacterSet NegativeCharacterSet(string, RegexQuantifier) Generates a negative character set expression (\"[^abc]\") using a preformatted character string. public static RegexNodeCharacterSet NegativeCharacterSet(string characters, RegexQuantifier quantifier) Parameters characters string Character set description. Special characters will be automatically escaped. quantifier RegexQuantifier Node quantifier. Returns RegexNodeCharacterSet An instance of RegexNode containing the character set. NegativeLookAhead(RegexNode, RegexNode) Generates a zero-width negative lookahead assertion (\"match(?!lookahead)\"). public static RegexNodeLookAround NegativeLookAhead(RegexNode lookupExpression, RegexNode matchExpression) Parameters lookupExpression RegexNode Lookahead expression. matchExpression RegexNode Match expression. Returns RegexNodeLookAround An instance of RegexNode containing the negative lookahead assertion. NegativeLookAhead(RegexNode, RegexNode, RegexQuantifier) Generates a zero-width negative lookahead assertion (\"match(?!lookahead)\"). public static RegexNodeLookAround NegativeLookAhead(RegexNode lookupExpression, RegexNode matchExpression, RegexQuantifier quantifier) Parameters lookupExpression RegexNode Lookahead expression. matchExpression RegexNode Match expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeLookAround An instance of RegexNode containing the negative lookahead assertion. NegativeLookBehind(RegexNode, RegexNode) Generates a zero-width negative lookbehind assertion (\"(?<!lookbehind)match\"). public static RegexNodeLookAround NegativeLookBehind(RegexNode lookupExpression, RegexNode matchExpression) Parameters lookupExpression RegexNode Lookbehind expression. matchExpression RegexNode Match expression. Returns RegexNodeLookAround An instance of RegexNode containing the negative lookbehind assertion. NegativeLookBehind(RegexNode, RegexNode, RegexQuantifier) Generates a zero-width negative lookbehind assertion (\"(?<!lookbehind)match\"). public static RegexNodeLookAround NegativeLookBehind(RegexNode lookupExpression, RegexNode matchExpression, RegexQuantifier quantifier) Parameters lookupExpression RegexNode Lookbehind expression. matchExpression RegexNode Match expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeLookAround An instance of RegexNode containing the negative lookbehind assertion. NegativeUnicodeCategory(string) Generates a negated Unicode category escape sequence (\"\\P{name}\") for matching characters NOT in a Unicode category. public static RegexNodeUnicodeCategory NegativeUnicodeCategory(string categoryName) Parameters categoryName string The Unicode category name (e.g., \"L\", \"N\", \"IsCyrillic\"). Returns RegexNodeUnicodeCategory An instance of RegexNode containing the negated Unicode category escape. NegativeUnicodeCategory(string, RegexQuantifier) Generates a negated Unicode category escape sequence (\"\\P{name}\") for matching characters NOT in a Unicode category with a quantifier. public static RegexNodeUnicodeCategory NegativeUnicodeCategory(string categoryName, RegexQuantifier quantifier) Parameters categoryName string The Unicode category name (e.g., \"L\", \"N\", \"IsCyrillic\"). quantifier RegexQuantifier Node quantifier. Returns RegexNodeUnicodeCategory An instance of RegexNode containing the negated Unicode category escape. NonCapturingGroup(RegexNode) Generates a non-capturing group with the specified subexpression. public static RegexNodeGroup NonCapturingGroup(RegexNode matchExpression) Parameters matchExpression RegexNode Inner expression. Returns RegexNodeGroup An instance of RegexNode containing the non-capturing group. NonCapturingGroup(RegexNode, RegexQuantifier) Generates a non-capturing group with the specified subexpression. public static RegexNodeGroup NonCapturingGroup(RegexNode matchExpression, RegexQuantifier quantifier) Parameters matchExpression RegexNode Inner expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeGroup An instance of RegexNode containing the non-capturing group. NonDigit() Generates a non-digit character class (\"\\D\"). public static RegexNodeLiteral NonDigit() Returns RegexNodeLiteral An instance of RegexNode containing the non-digit character class. NonDigit(RegexQuantifier) Generates a non-digit character class (\"\\D\") with a quantifier. public static RegexNodeLiteral NonDigit(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the non-digit character class. NonEscapedLiteral(string) Generates a simple string literal \"as is\", without character escaping. This method can be used to render explicit preformatted patterns of the Regex or some rare constructions not supported by RegexBuilder. public static RegexNodeLiteral NonEscapedLiteral(string value) Parameters value string Node text. Returns RegexNodeLiteral An instance of RegexNode containing the specified text. NonEscapedLiteral(string, RegexQuantifier) Generates a simple string literal \"as is\", without character escaping. This method can be used to render explicit preformatted patterns of the Regex or some rare constructions not supported by RegexBuilder. public static RegexNodeLiteral NonEscapedLiteral(string value, RegexQuantifier quantifier) Parameters value string Node text. quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the specified text. NonWhitespace() Generates a non-whitespace character class (\"\\S\"). public static RegexNodeLiteral NonWhitespace() Returns RegexNodeLiteral An instance of RegexNode containing the non-whitespace character class. NonWhitespace(RegexQuantifier) Generates a non-whitespace character class (\"\\S\") with a quantifier. public static RegexNodeLiteral NonWhitespace(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the non-whitespace character class. NonWordBoundary() Generates a non-word boundary anchor (\"\\B\"). public static RegexNodeLiteral NonWordBoundary() Returns RegexNodeLiteral An instance of RegexNode containing the non-word boundary anchor. NonWordCharacter() Generates a non-word character class (\"\\W\"). public static RegexNodeLiteral NonWordCharacter() Returns RegexNodeLiteral An instance of RegexNode containing the non-word character class. NonWordCharacter(RegexQuantifier) Generates a non-word character class (\"\\W\") with a quantifier. public static RegexNodeLiteral NonWordCharacter(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the non-word character class. OctalCharacter(int) Generates an octal character escape sequence (\"\\NNN\") with the specified octal value. public static RegexNodeLiteral OctalCharacter(int octalValue) Parameters octalValue int Octal value (0-377 for 0-255 decimal). Returns RegexNodeLiteral An instance of RegexNode containing the octal character escape. OctalCharacter(int, RegexQuantifier) Generates an octal character escape sequence (\"\\NNN\") with the specified octal value and quantifier. public static RegexNodeLiteral OctalCharacter(int octalValue, RegexQuantifier quantifier) Parameters octalValue int Octal value (0-377 for 0-255 decimal). quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the octal character escape. Pattern() Creates a new PatternBuilder instance for building complex regex patterns using a fluent API. public static PatternBuilder Pattern() Returns PatternBuilder A new PatternBuilder instance. PositiveLookAhead(RegexNode, RegexNode) Generates a zero-width positive lookahead assertion (\"match(?=lookahead)\"). public static RegexNodeLookAround PositiveLookAhead(RegexNode lookupExpression, RegexNode matchExpression) Parameters lookupExpression RegexNode Lookahead expression. matchExpression RegexNode Match expression. Returns RegexNodeLookAround An instance of RegexNode containing the positive lookahead assertion. PositiveLookAhead(RegexNode, RegexNode, RegexQuantifier) Generates a zero-width positive lookahead assertion (\"match(?=lookahead)\"). public static RegexNodeLookAround PositiveLookAhead(RegexNode lookupExpression, RegexNode matchExpression, RegexQuantifier quantifier) Parameters lookupExpression RegexNode Lookahead expression. matchExpression RegexNode Match expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeLookAround An instance of RegexNode containing the positive lookahead assertion. PositiveLookBehind(RegexNode, RegexNode) Generates a zero-width positive lookbehind assertion (\"(?<=lookbehind)match\"). public static RegexNodeLookAround PositiveLookBehind(RegexNode lookupExpression, RegexNode matchExpression) Parameters lookupExpression RegexNode Lookbehind expression. matchExpression RegexNode Match expression. Returns RegexNodeLookAround An instance of RegexNode containing the positive lookbehind assertion. PositiveLookBehind(RegexNode, RegexNode, RegexQuantifier) Generates a zero-width positive lookbehind assertion (\"(?<=lookbehind)match\"). public static RegexNodeLookAround PositiveLookBehind(RegexNode lookupExpression, RegexNode matchExpression, RegexQuantifier quantifier) Parameters lookupExpression RegexNode Lookbehind expression. matchExpression RegexNode Match expression. quantifier RegexQuantifier Node quantifier. Returns RegexNodeLookAround An instance of RegexNode containing the positive lookbehind assertion. SimpleBalancingGroup(string, RegexNode) Generates a simple balancing group that only uses one stack. Used for matching nested/balanced constructs like parentheses, XML tags, or code blocks. Syntax: (?<name>-expr) public static RegexNodeBalancingGroup SimpleBalancingGroup(string groupName, RegexNode innerExpression) Parameters groupName string Name of group to push onto the stack. innerExpression RegexNode The inner expression to match. Returns RegexNodeBalancingGroup An instance of RegexNode containing the simple balancing group. SimpleBalancingGroup(string, RegexNode, RegexQuantifier) Generates a simple balancing group that only uses one stack, with a quantifier. Used for matching nested/balanced constructs like parentheses, XML tags, or code blocks. Syntax: (?<name>-expr) public static RegexNodeBalancingGroup SimpleBalancingGroup(string groupName, RegexNode innerExpression, RegexQuantifier quantifier) Parameters groupName string Name of group to push onto the stack. innerExpression RegexNode The inner expression to match. quantifier RegexQuantifier Node quantifier. Returns RegexNodeBalancingGroup An instance of RegexNode containing the simple balancing group. StringEnd() Generates a string end anchor (\"\\Z\"). public static RegexNodeLiteral StringEnd() Returns RegexNodeLiteral An instance of RegexNode containing the string end anchor. StringEndAbsolute() Generates an absolute string end anchor (\"\\z\"). public static RegexNodeLiteral StringEndAbsolute() Returns RegexNodeLiteral An instance of RegexNode containing the absolute string end anchor. StringStart() Generates a string start anchor (\"\\A\"). public static RegexNodeLiteral StringStart() Returns RegexNodeLiteral An instance of RegexNode containing the string start anchor. UnicodeCategory(string) Generates a Unicode category escape sequence (\"\\p{name}\") for matching Unicode character categories. public static RegexNodeUnicodeCategory UnicodeCategory(string categoryName) Parameters categoryName string The Unicode category name (e.g., \"L\", \"N\", \"IsCyrillic\"). Returns RegexNodeUnicodeCategory An instance of RegexNode containing the Unicode category escape. UnicodeCategory(string, RegexQuantifier) Generates a Unicode category escape sequence (\"\\p{name}\") for matching Unicode character categories with a quantifier. public static RegexNodeUnicodeCategory UnicodeCategory(string categoryName, RegexQuantifier quantifier) Parameters categoryName string The Unicode category name (e.g., \"L\", \"N\", \"IsCyrillic\"). quantifier RegexQuantifier Node quantifier. Returns RegexNodeUnicodeCategory An instance of RegexNode containing the Unicode category escape. UnicodeCharacter(int) Generates a Unicode character pattern (\"\\uNNNN\") with the specified character code. public static RegexNodeLiteral UnicodeCharacter(int code) Parameters code int Unicode character code. Returns RegexNodeLiteral An instance of RegexNode containing the specified Unicode character. UnicodeCharacter(int, RegexQuantifier) Generates a Unicode character pattern (\"\\uNNNN\") with the specified character code. public static RegexNodeLiteral UnicodeCharacter(int code, RegexQuantifier quantifier) Parameters code int Unicode character code. quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the specified Unicode character. VerticalTab() Generates a vertical tab character escape sequence (\"\\v\", ASCII 11). public static RegexNodeLiteral VerticalTab() Returns RegexNodeLiteral An instance of RegexNode containing the vertical tab character escape. VerticalTab(RegexQuantifier) Generates a vertical tab character escape sequence (\"\\v\", ASCII 11) with a quantifier. public static RegexNodeLiteral VerticalTab(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the vertical tab character escape. Whitespace() Generates a whitespace character class (\"\\s\"). public static RegexNodeLiteral Whitespace() Returns RegexNodeLiteral An instance of RegexNode containing the whitespace character class. Whitespace(RegexQuantifier) Generates a whitespace character class (\"\\s\") with a quantifier. public static RegexNodeLiteral Whitespace(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the whitespace character class. WordBoundary() Generates a word boundary anchor (\"\\b\"). public static RegexNodeLiteral WordBoundary() Returns RegexNodeLiteral An instance of RegexNode containing the word boundary anchor. WordCharacter() Generates a word character class (\"\\w\"). public static RegexNodeLiteral WordCharacter() Returns RegexNodeLiteral An instance of RegexNode containing the word character class. WordCharacter(RegexQuantifier) Generates a word character class (\"\\w\") with a quantifier. public static RegexNodeLiteral WordCharacter(RegexQuantifier quantifier) Parameters quantifier RegexQuantifier Node quantifier. Returns RegexNodeLiteral An instance of RegexNode containing the word character class."
  },
  "api/RegexBuilder.RegexLookAround.html": {
    "href": "api/RegexBuilder.RegexLookAround.html",
    "title": "Enum RegexLookAround | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Enum RegexLookAround Namespace RegexBuilder Assembly RegexBuilder.dll public enum RegexLookAround Fields NegativeLookAhead = 2 NegativeLookBehind = 3 PositiveLookAhead = 0 PositiveLookBehind = 1"
  },
  "api/RegexBuilder.RegexMetaChars.html": {
    "href": "api/RegexBuilder.RegexMetaChars.html",
    "title": "Class RegexMetaChars | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexMetaChars Namespace RegexBuilder Assembly RegexBuilder.dll public static class RegexMetaChars Inheritance object RegexMetaChars Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields AnyCharacter public const string AnyCharacter = \".\" Field Value string CarriageReturn public const string CarriageReturn = \"\\\\r\" Field Value string ConsecutiveMatch public const string ConsecutiveMatch = \"\\\\G\" Field Value string Digit public const string Digit = \"\\\\d\" Field Value string Escape public const string Escape = \"\\\\e\" Field Value string FormFeed public const string FormFeed = \"\\\\f\" Field Value string LineEnd public const string LineEnd = \"$\" Field Value string LineStart public const string LineStart = \"^\" Field Value string NewLine public const string NewLine = \"\\\\n\" Field Value string NonDigit public const string NonDigit = \"\\\\D\" Field Value string NonWordBoundary public const string NonWordBoundary = \"\\\\B\" Field Value string NonWordCharacter public const string NonWordCharacter = \"\\\\W\" Field Value string NonwhiteSpace public const string NonwhiteSpace = \"\\\\S\" Field Value string StringEnd public const string StringEnd = \"\\\\Z\" Field Value string StringStart public const string StringStart = \"\\\\A\" Field Value string Tab public const string Tab = \"\\\\t\" Field Value string VerticalTab public const string VerticalTab = \"\\\\v\" Field Value string WhiteSpace public const string WhiteSpace = \"\\\\s\" Field Value string WordBoundary public const string WordBoundary = \"\\\\b\" Field Value string WordCharacter public const string WordCharacter = \"\\\\w\" Field Value string Methods GetGeneralCategories() Gets all supported Unicode general categories. public static IEnumerable<string> GetGeneralCategories() Returns IEnumerable<string> An enumeration of supported Unicode general category names. GetNamedBlocks() Gets all supported Unicode named blocks. public static IEnumerable<string> GetNamedBlocks() Returns IEnumerable<string> An enumeration of supported Unicode named block names. IsValidUnicodeCategory(string) Validates whether a Unicode category name is supported. public static bool IsValidUnicodeCategory(string categoryName) Parameters categoryName string The category name to validate. Returns bool True if the category is supported; otherwise, false."
  },
  "api/RegexBuilder.RegexNode.html": {
    "href": "api/RegexBuilder.RegexNode.html",
    "title": "Class RegexNode | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNode Namespace RegexBuilder Assembly RegexBuilder.dll public abstract class RegexNode Inheritance object RegexNode Derived RegexNodeAlternation RegexNodeBacktrackingSuppression RegexNodeBalancingGroup RegexNodeCharacterRange RegexNodeCharacterSet RegexNodeComment RegexNodeConcatenation RegexNodeConditionalMatch RegexNodeGroup RegexNodeGroupReference RegexNodeInlineOption RegexNodeInlineOptionGrouping RegexNodeLiteral RegexNodeLookAround RegexNodeUnicodeCategory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties AllowQuantifier protected abstract bool AllowQuantifier { get; } Property Value bool HasQuantifier protected bool HasQuantifier { get; } Property Value bool Quantifier Gets or sets a RegexQuantifier associated with this node. public RegexQuantifier Quantifier { get; set; } Property Value RegexQuantifier Methods Add(RegexNode, RegexNode) public static RegexNode Add(RegexNode node1, RegexNode node2) Parameters node1 RegexNode node2 RegexNode Returns RegexNode ToRegexPattern() Converts RegexNode to a Regex pattern string. public abstract string ToRegexPattern() Returns string Operators operator +(RegexNode, RegexNode) public static RegexNode operator +(RegexNode node1, RegexNode node2) Parameters node1 RegexNode node2 RegexNode Returns RegexNode"
  },
  "api/RegexBuilder.RegexNodeAlternation.html": {
    "href": "api/RegexBuilder.RegexNodeAlternation.html",
    "title": "Class RegexNodeAlternation | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeAlternation Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeAlternation : RegexNode Inheritance object RegexNode RegexNodeAlternation Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeAlternation(RegexNode, RegexNode) public RegexNodeAlternation(RegexNode expression1, RegexNode expression2) Parameters expression1 RegexNode expression2 RegexNode RegexNodeAlternation(params RegexNode[]) public RegexNodeAlternation(params RegexNode[] expressions) Parameters expressions RegexNode[] Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool Expressions public IEnumerable<RegexNode> Expressions { get; } Property Value IEnumerable<RegexNode> Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeBacktrackingSuppression.html": {
    "href": "api/RegexBuilder.RegexNodeBacktrackingSuppression.html",
    "title": "Class RegexNodeBacktrackingSuppression | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeBacktrackingSuppression Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeBacktrackingSuppression : RegexNode Inheritance object RegexNode RegexNodeBacktrackingSuppression Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeBacktrackingSuppression(RegexNode) public RegexNodeBacktrackingSuppression(RegexNode innerExpression) Parameters innerExpression RegexNode Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool InnerExpression public RegexNode InnerExpression { get; set; } Property Value RegexNode Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeBalancingGroup.html": {
    "href": "api/RegexBuilder.RegexNodeBalancingGroup.html",
    "title": "Class RegexNodeBalancingGroup | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeBalancingGroup Namespace RegexBuilder Assembly RegexBuilder.dll Represents a balancing group construct in a regular expression. Balancing groups are used to match nested/balanced constructs such as parentheses, XML tags, or code blocks. Supports both two-name form (?<name1-name2>expr) and single-name form (?<name>-expr). public class RegexNodeBalancingGroup : RegexNode Inheritance object RegexNode RegexNodeBalancingGroup Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks Balancing groups work by maintaining a stack of captured groups. The syntax (?<name1-name2>expr) captures to 'name1' and pops 'name2' from the stack. This is useful for matching balanced constructs. Example: ( (?:[^()] | (?<paren>() | (?<-paren>)))*+ ) matches balanced parentheses. Constructors RegexNodeBalancingGroup(string, RegexNode) Initializes a new instance of the RegexNodeBalancingGroup class with a single group name. Creates a simple balancing group with syntax: (?<name>-expr) public RegexNodeBalancingGroup(string groupName, RegexNode innerExpression) Parameters groupName string The name of the group to push onto the stack. innerExpression RegexNode The inner expression to match. RegexNodeBalancingGroup(string, string, RegexNode) Initializes a new instance of the RegexNodeBalancingGroup class with two group names. Creates a balancing group with syntax: (?<pushName-popName>expr) public RegexNodeBalancingGroup(string pushGroupName, string popGroupName, RegexNode innerExpression) Parameters pushGroupName string The name of the group to push onto the stack. popGroupName string The name of the group to pop from the stack. innerExpression RegexNode The inner expression to match. Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool InnerExpression Gets or sets the inner expression to match within the balancing group. public RegexNode InnerExpression { get; set; } Property Value RegexNode IsSimpleBalancing Gets a value indicating whether this is a simple balancing group (single name only). Simple balancing groups use syntax: (?<name>-expr) public bool IsSimpleBalancing { get; } Property Value bool PopGroupName Gets or sets the name of the group to pop from the stack. In (?<name1-name2>expr), this is 'name2'. If null or empty, only push operation is performed: (?<name>-expr). public string PopGroupName { get; set; } Property Value string PushGroupName Gets or sets the name of the group to push onto the stack. In (?<name1-name2>expr), this is 'name1'. public string PushGroupName { get; set; } Property Value string Methods ToRegexPattern() Converts this node to a regular expression pattern string. public override string ToRegexPattern() Returns string A regular expression pattern string. Returns (?<name1-name2>expr) for two-name balancing groups. Returns (?<name>-expr) for simple balancing groups."
  },
  "api/RegexBuilder.RegexNodeCharacterRange.html": {
    "href": "api/RegexBuilder.RegexNodeCharacterRange.html",
    "title": "Class RegexNodeCharacterRange | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeCharacterRange Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeCharacterRange : RegexNode Inheritance object RegexNode RegexNodeCharacterRange Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeCharacterRange(char, char, bool) public RegexNodeCharacterRange(char rangeStart, char rangeEnd, bool isNegative) Parameters rangeStart char rangeEnd char isNegative bool Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool IsNegative public bool IsNegative { get; set; } Property Value bool RangeEnd public char RangeEnd { get; set; } Property Value char RangeStart public char RangeStart { get; set; } Property Value char UseCharacterCodes public bool UseCharacterCodes { get; set; } Property Value bool Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeCharacterSet.html": {
    "href": "api/RegexBuilder.RegexNodeCharacterSet.html",
    "title": "Class RegexNodeCharacterSet | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeCharacterSet Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeCharacterSet : RegexNode Inheritance object RegexNode RegexNodeCharacterSet Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeCharacterSet(char[], bool) public RegexNodeCharacterSet(char[] characters, bool isNegative) Parameters characters char[] isNegative bool RegexNodeCharacterSet(string, bool) public RegexNodeCharacterSet(string characterListExpression, bool isNegative) Parameters characterListExpression string isNegative bool Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool CharacterListExpression public string CharacterListExpression { get; set; } Property Value string Characters public IEnumerable<char> Characters { get; } Property Value IEnumerable<char> IsNegative public bool IsNegative { get; set; } Property Value bool UseCharacterCodes public bool UseCharacterCodes { get; set; } Property Value bool Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeComment.html": {
    "href": "api/RegexBuilder.RegexNodeComment.html",
    "title": "Class RegexNodeComment | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeComment Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeComment : RegexNode Inheritance object RegexNode RegexNodeComment Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeComment(string) public RegexNodeComment(string commentText) Parameters commentText string Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool CommentText public string CommentText { get; set; } Property Value string Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeConcatenation.html": {
    "href": "api/RegexBuilder.RegexNodeConcatenation.html",
    "title": "Class RegexNodeConcatenation | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeConcatenation Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeConcatenation : RegexNode Inheritance object RegexNode RegexNodeConcatenation Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeConcatenation() public RegexNodeConcatenation() RegexNodeConcatenation(params RegexNode[]) public RegexNodeConcatenation(params RegexNode[] childNodes) Parameters childNodes RegexNode[] RegexNodeConcatenation(IList<RegexNode>) public RegexNodeConcatenation(IList<RegexNode> childNodes) Parameters childNodes IList<RegexNode> Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool ChildNodes public IList<RegexNode> ChildNodes { get; } Property Value IList<RegexNode> Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeConditionalMatch.html": {
    "href": "api/RegexBuilder.RegexNodeConditionalMatch.html",
    "title": "Class RegexNodeConditionalMatch | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeConditionalMatch Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeConditionalMatch : RegexNode Inheritance object RegexNode RegexNodeConditionalMatch Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeConditionalMatch(RegexNode, RegexNode, RegexNode) public RegexNodeConditionalMatch(RegexNode conditionExpression, RegexNode trueMatchExpression, RegexNode falseMatchExpression) Parameters conditionExpression RegexNode trueMatchExpression RegexNode falseMatchExpression RegexNode RegexNodeConditionalMatch(string, RegexNode, RegexNode) public RegexNodeConditionalMatch(string conditionGroupName, RegexNode trueMatchExpression, RegexNode falseMatchExpression) Parameters conditionGroupName string trueMatchExpression RegexNode falseMatchExpression RegexNode Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool ConditionExpression public RegexNode ConditionExpression { get; set; } Property Value RegexNode ConditionGroupName public string ConditionGroupName { get; set; } Property Value string FalseMatchExpression public RegexNode FalseMatchExpression { get; set; } Property Value RegexNode TrueMatchExpression public RegexNode TrueMatchExpression { get; set; } Property Value RegexNode Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeEscapingLiteral.html": {
    "href": "api/RegexBuilder.RegexNodeEscapingLiteral.html",
    "title": "Class RegexNodeEscapingLiteral | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeEscapingLiteral Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeEscapingLiteral : RegexNodeLiteral Inheritance object RegexNode RegexNodeLiteral RegexNodeEscapingLiteral Inherited Members RegexNodeLiteral.Value RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeEscapingLiteral(string) public RegexNodeEscapingLiteral(string value) Parameters value string Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeGroup.html": {
    "href": "api/RegexBuilder.RegexNodeGroup.html",
    "title": "Class RegexNodeGroup | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeGroup Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeGroup : RegexNode Inheritance object RegexNode RegexNodeGroup Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeGroup(RegexNode) public RegexNodeGroup(RegexNode innerExpression) Parameters innerExpression RegexNode RegexNodeGroup(RegexNode, bool) public RegexNodeGroup(RegexNode innerExpression, bool isCapturing) Parameters innerExpression RegexNode isCapturing bool RegexNodeGroup(RegexNode, string) public RegexNodeGroup(RegexNode innerExpression, string name) Parameters innerExpression RegexNode name string Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool InnerExpression public RegexNode InnerExpression { get; set; } Property Value RegexNode IsCapturing public bool IsCapturing { get; set; } Property Value bool Name public string Name { get; set; } Property Value string UseApostropheSyntax public bool UseApostropheSyntax { get; set; } Property Value bool Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeGroupReference.html": {
    "href": "api/RegexBuilder.RegexNodeGroupReference.html",
    "title": "Class RegexNodeGroupReference | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeGroupReference Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeGroupReference : RegexNode Inheritance object RegexNode RegexNodeGroupReference Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeGroupReference(int?) public RegexNodeGroupReference(int? groupIndex) Parameters groupIndex int? RegexNodeGroupReference(string) public RegexNodeGroupReference(string groupName) Parameters groupName string Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool GroupIndex public int? GroupIndex { get; set; } Property Value int? GroupName public string GroupName { get; set; } Property Value string Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeInlineOption.html": {
    "href": "api/RegexBuilder.RegexNodeInlineOption.html",
    "title": "Class RegexNodeInlineOption | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeInlineOption Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeInlineOption : RegexNode Inheritance object RegexNode RegexNodeInlineOption Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeInlineOption(RegexOptions, RegexNode) public RegexNodeInlineOption(RegexOptions options, RegexNode innerExpression) Parameters options RegexOptions innerExpression RegexNode Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool InnerExpression public RegexNode InnerExpression { get; set; } Property Value RegexNode Options public RegexOptions Options { get; set; } Property Value RegexOptions Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeInlineOptionGrouping.html": {
    "href": "api/RegexBuilder.RegexNodeInlineOptionGrouping.html",
    "title": "Class RegexNodeInlineOptionGrouping | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeInlineOptionGrouping Namespace RegexBuilder Assembly RegexBuilder.dll Represents an inline option grouping node with support for enabling and disabling options. Generates patterns like (?i:expr), (?im:expr), or (?i-m:expr). public class RegexNodeInlineOptionGrouping : RegexNode Inheritance object RegexNode RegexNodeInlineOptionGrouping Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeInlineOptionGrouping(RegexOptions, RegexNode) Initializes a new instance of the RegexNodeInlineOptionGrouping class. public RegexNodeInlineOptionGrouping(RegexOptions enabledOptions, RegexNode innerExpression) Parameters enabledOptions RegexOptions Options to enable. innerExpression RegexNode Inner expression. RegexNodeInlineOptionGrouping(RegexOptions, RegexOptions, RegexNode) Initializes a new instance of the RegexNodeInlineOptionGrouping class with both enabled and disabled options. public RegexNodeInlineOptionGrouping(RegexOptions enabledOptions, RegexOptions disabledOptions, RegexNode innerExpression) Parameters enabledOptions RegexOptions Options to enable. disabledOptions RegexOptions Options to disable. innerExpression RegexNode Inner expression. Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool DisabledOptions Gets or sets the options to be disabled for this group. public RegexOptions DisabledOptions { get; set; } Property Value RegexOptions EnabledOptions Gets or sets the options to be enabled for this group. public RegexOptions EnabledOptions { get; set; } Property Value RegexOptions InnerExpression Gets or sets the inner expression for this grouping. public RegexNode InnerExpression { get; set; } Property Value RegexNode Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeLiteral.html": {
    "href": "api/RegexBuilder.RegexNodeLiteral.html",
    "title": "Class RegexNodeLiteral | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeLiteral Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeLiteral : RegexNode Inheritance object RegexNode RegexNodeLiteral Derived RegexNodeEscapingLiteral Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeLiteral(string) public RegexNodeLiteral(string value) Parameters value string Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool Value public string Value { get; set; } Property Value string Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeLookAround.html": {
    "href": "api/RegexBuilder.RegexNodeLookAround.html",
    "title": "Class RegexNodeLookAround | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeLookAround Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexNodeLookAround : RegexNode Inheritance object RegexNode RegexNodeLookAround Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeLookAround(RegexLookAround, RegexNode, RegexNode) public RegexNodeLookAround(RegexLookAround lookAroundType, RegexNode lookAroundExpression, RegexNode matchExpression) Parameters lookAroundType RegexLookAround lookAroundExpression RegexNode matchExpression RegexNode Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool LookAroundExpression public RegexNode LookAroundExpression { get; set; } Property Value RegexNode LookAroundType public RegexLookAround LookAroundType { get; set; } Property Value RegexLookAround MatchExpression public RegexNode MatchExpression { get; set; } Property Value RegexNode Methods ToRegexPattern() Converts RegexNode to a Regex pattern string. public override string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexNodeUnicodeCategory.html": {
    "href": "api/RegexBuilder.RegexNodeUnicodeCategory.html",
    "title": "Class RegexNodeUnicodeCategory | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexNodeUnicodeCategory Namespace RegexBuilder Assembly RegexBuilder.dll Represents a Unicode category escape sequence in a regular expression. Enables matching of Unicode letters, numbers, and other character categories. Supports both positive matching (\\p{name}) and negative matching (\\P{name}). public class RegexNodeUnicodeCategory : RegexNode Inheritance object RegexNode RegexNodeUnicodeCategory Inherited Members RegexNode.HasQuantifier RegexNode.Quantifier RegexNode.Add(RegexNode, RegexNode) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexNodeUnicodeCategory(string) Initializes a new instance of the RegexNodeUnicodeCategory class. public RegexNodeUnicodeCategory(string categoryName) Parameters categoryName string The Unicode category name. RegexNodeUnicodeCategory(string, bool) Initializes a new instance of the RegexNodeUnicodeCategory class. public RegexNodeUnicodeCategory(string categoryName, bool isNegated) Parameters categoryName string The Unicode category name. isNegated bool If true, generates \\P{name} instead of \\p{name}. Properties AllowQuantifier protected override bool AllowQuantifier { get; } Property Value bool CategoryName Gets or sets the Unicode category name (e.g., \"L\", \"N\", \"IsCyrillic\"). public string CategoryName { get; set; } Property Value string IsNegated Gets or sets a value indicating whether this category should be negated (use \\P instead of \\p). public bool IsNegated { get; set; } Property Value bool Methods ToRegexPattern() Converts this node to a regular expression pattern string. public override string ToRegexPattern() Returns string The regular expression pattern string (e.g., \"\\p{L}\", \"\\P{N}\")."
  },
  "api/RegexBuilder.RegexQuantifier.html": {
    "href": "api/RegexBuilder.RegexQuantifier.html",
    "title": "Class RegexQuantifier | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexQuantifier Namespace RegexBuilder Assembly RegexBuilder.dll public class RegexQuantifier Inheritance object RegexQuantifier Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RegexQuantifier() Initializes a new instance of RegexQuantifier. public RegexQuantifier() RegexQuantifier(int?, int?) Initializes a new instance of RegexQuantifier. public RegexQuantifier(int? minOccurrenceCount, int? maxOccurrenceCount) Parameters minOccurrenceCount int? Minimum occurrence count. maxOccurrenceCount int? Maximum occurrence count. RegexQuantifier(int?, int?, bool) Initializes a new instance of RegexQuantifier. public RegexQuantifier(int? minOccurrenceCount, int? maxOccurrenceCount, bool isLazy) Parameters minOccurrenceCount int? Minimum occurrence count. maxOccurrenceCount int? Maximum occurrence count. isLazy bool True - use lazy quantifier. False - use greedy quantifier. Properties IsLazy Specifies whether the quantified expression should be matched as few times as possible. public bool IsLazy { get; set; } Property Value bool MaxOccurrenceCount Maximum occurrence count. NULL = unlimited. public int? MaxOccurrenceCount { get; set; } Property Value int? MinOccurrenceCount Minimum occurrence count. public int? MinOccurrenceCount { get; set; } Property Value int? None NULL quantifier. public static RegexQuantifier None { get; } Property Value RegexQuantifier OneOrMore The \"+\" quantifier. public static RegexQuantifier OneOrMore { get; } Property Value RegexQuantifier OneOrMoreLazy The \"+?\" quantifier. public static RegexQuantifier OneOrMoreLazy { get; } Property Value RegexQuantifier ZeroOrMore The \"*\" quantifier. public static RegexQuantifier ZeroOrMore { get; } Property Value RegexQuantifier ZeroOrMoreLazy The \"*?\" quantifier. public static RegexQuantifier ZeroOrMoreLazy { get; } Property Value RegexQuantifier ZeroOrOne The \"?\" quantifier. public static RegexQuantifier ZeroOrOne { get; } Property Value RegexQuantifier ZeroOrOneLazy The \"??\" quantifier. public static RegexQuantifier ZeroOrOneLazy { get; } Property Value RegexQuantifier Methods AtLeast(int) The \"{n,}\" quantifier. Minimum occurrence count. public static RegexQuantifier AtLeast(int minOccurrenceCount) Parameters minOccurrenceCount int Returns RegexQuantifier An instance of RegexQuantifier with the specified options. AtLeast(int, bool) The \"{n,}\" or \"{n,}?\" quantifier. Minimum occurrence count. True - use lazy quantifier. False - use greedy quantifier. public static RegexQuantifier AtLeast(int minOccurrenceCount, bool isLazy) Parameters minOccurrenceCount int isLazy bool Returns RegexQuantifier An instance of RegexQuantifier with the specified options. Custom(int?, int?, bool) Custom \"{n,m}\" or \"{n,m}?\" quantifier. public static RegexQuantifier Custom(int? minOccurrenceCount, int? maxOccurrenceCount, bool isLazy) Parameters minOccurrenceCount int? Minimum occurrence count. maxOccurrenceCount int? Maximum occurrence count. isLazy bool True - use lazy quantifier. False - use greedy quantifier. Returns RegexQuantifier An instance of RegexQuantifier with the specified options. Exactly(int) The \"{n}\" or \"{n}?\" quantifier. Exact occurrence count. public static RegexQuantifier Exactly(int occurrenceCount) Parameters occurrenceCount int Returns RegexQuantifier An instance of RegexQuantifier with the specified options. Exactly(int, bool) The \"{n}\" or \"{n}?\" quantifier. Exact occurrence count. True - use lazy quantifier. False - use greedy quantifier. public static RegexQuantifier Exactly(int occurrenceCount, bool isLazy) Parameters occurrenceCount int isLazy bool Returns RegexQuantifier An instance of RegexQuantifier with the specified options. ToRegexPattern() Converts RegexQuantifier to a Regex pattern string. public virtual string ToRegexPattern() Returns string"
  },
  "api/RegexBuilder.RegexStringEscaper.html": {
    "href": "api/RegexBuilder.RegexStringEscaper.html",
    "title": "Class RegexStringEscaper | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class RegexStringEscaper Namespace RegexBuilder Assembly RegexBuilder.dll public static class RegexStringEscaper Inheritance object RegexStringEscaper Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Escape(string, bool) public static string Escape(string value, bool escapeBackslash) Parameters value string escapeBackslash bool Returns string"
  },
  "api/RegexBuilder.SubstitutionBuilder.html": {
    "href": "api/RegexBuilder.SubstitutionBuilder.html",
    "title": "Class SubstitutionBuilder | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class SubstitutionBuilder Namespace RegexBuilder Assembly RegexBuilder.dll Factory class for creating substitution/replacement pattern nodes. Use these methods to build replacement patterns for Regex.Replace() operations. public static class SubstitutionBuilder Inheritance object SubstitutionBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AfterMatch() Creates a substitution that outputs all text after the match. Equivalent to the $' substitution pattern. public static SubstitutionSpecialReference AfterMatch() Returns SubstitutionSpecialReference A substitution node that outputs the text after the match. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.AfterMatch() ); // Replaces the match with everything that comes after it BeforeMatch() Creates a substitution that outputs all text before the match. Equivalent to the $` substitution pattern. public static SubstitutionSpecialReference BeforeMatch() Returns SubstitutionSpecialReference A substitution node that outputs the text before the match. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.BeforeMatch() ); // Replaces the match with everything that came before it Build(SubstitutionNode) Builds a substitution pattern string from a single substitution node. public static string Build(SubstitutionNode node) Parameters node SubstitutionNode The substitution node to convert. Returns string A string that can be used as a replacement pattern in Regex.Replace(). Build(params SubstitutionNode[]) Builds a substitution pattern string from multiple substitution nodes. The nodes are concatenated in the order provided. public static string Build(params SubstitutionNode[] nodes) Parameters nodes SubstitutionNode[] The substitution nodes to concatenate. Returns string A string that can be used as a replacement pattern in Regex.Replace(). Concatenate(params SubstitutionNode[]) Creates a concatenation of multiple substitution nodes. This is equivalent to calling Build() with multiple nodes, but returns a SubstitutionNode that can be used as part of a larger substitution pattern. public static SubstitutionConcatenation Concatenate(params SubstitutionNode[] nodes) Parameters nodes SubstitutionNode[] The substitution nodes to concatenate. Returns SubstitutionConcatenation A substitution node representing the concatenation. Examples var part1 = SubstitutionBuilder.Concatenate( SubstitutionBuilder.Literal(\"(\"), SubstitutionBuilder.Group(1), SubstitutionBuilder.Literal(\")\") ); var replacement = SubstitutionBuilder.Build( part1, SubstitutionBuilder.Literal(\" \"), SubstitutionBuilder.Group(2) ); EntireInput() Creates a substitution that outputs the entire input string. Equivalent to the $_ substitution pattern. public static SubstitutionSpecialReference EntireInput() Returns SubstitutionSpecialReference A substitution node that outputs the entire input string. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.EntireInput() ); // Replaces the match with the entire input string Group(int) Creates a substitution that references a numbered capturing group. public static SubstitutionGroupReference Group(int groupNumber) Parameters groupNumber int The 1-based group number to reference. Returns SubstitutionGroupReference A substitution node that outputs the value of the specified group. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.Group(2), SubstitutionBuilder.Literal(\" \"), SubstitutionBuilder.Group(1) ); // Produces: \"$2 $1\" Group(string) Creates a substitution that references a named capturing group. public static SubstitutionGroupReference Group(string groupName) Parameters groupName string The name of the group to reference. Returns SubstitutionGroupReference A substitution node that outputs the value of the specified named group. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.Group(\"word2\"), SubstitutionBuilder.Literal(\" \"), SubstitutionBuilder.Group(\"word1\") ); // Produces: \"${word2} ${word1}\" LastCapturedGroup() Creates a substitution that outputs the last captured group. Equivalent to the $+ substitution pattern. public static SubstitutionSpecialReference LastCapturedGroup() Returns SubstitutionSpecialReference A substitution node that outputs the last captured group. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.LastCapturedGroup() ); // Outputs the last group that was captured in the match Literal(string) Creates a literal text substitution node. Dollar signs ($) are automatically escaped. public static SubstitutionLiteral Literal(string text) Parameters text string The literal text to include in the replacement. Returns SubstitutionLiteral A substitution node representing the literal text. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.Literal(\"Hello \") ); LiteralDollar() Creates a substitution that outputs a literal dollar sign ($). Equivalent to the $$ substitution pattern. Note: This is rarely needed as the Literal() method automatically escapes dollar signs. public static SubstitutionSpecialReference LiteralDollar() Returns SubstitutionSpecialReference A substitution node that outputs a literal dollar sign. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.LiteralDollar(), SubstitutionBuilder.Group(1) ); // Produces: \"$$1\" which outputs \"$\" followed by the value of group 1 WholeMatch() Creates a substitution that outputs the entire matched text. Equivalent to the $& substitution pattern. public static SubstitutionSpecialReference WholeMatch() Returns SubstitutionSpecialReference A substitution node that outputs the whole match. Examples var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.Literal(\"[\"), SubstitutionBuilder.WholeMatch(), SubstitutionBuilder.Literal(\"]\") ); // Wraps the matched text in brackets"
  },
  "api/RegexBuilder.SubstitutionConcatenation.html": {
    "href": "api/RegexBuilder.SubstitutionConcatenation.html",
    "title": "Class SubstitutionConcatenation | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class SubstitutionConcatenation Namespace RegexBuilder Assembly RegexBuilder.dll Represents a concatenation of multiple substitution nodes. public class SubstitutionConcatenation : SubstitutionNode Inheritance object SubstitutionNode SubstitutionConcatenation Inherited Members SubstitutionNode.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors SubstitutionConcatenation(params SubstitutionNode[]) Initializes a new instance with the specified child nodes. public SubstitutionConcatenation(params SubstitutionNode[] childNodes) Parameters childNodes SubstitutionNode[] The substitution nodes to concatenate. SubstitutionConcatenation(IEnumerable<SubstitutionNode>) Initializes a new instance with the specified child nodes. public SubstitutionConcatenation(IEnumerable<SubstitutionNode> childNodes) Parameters childNodes IEnumerable<SubstitutionNode> The substitution nodes to concatenate. Properties ChildNodes Gets the child substitution nodes. public IReadOnlyList<SubstitutionNode> ChildNodes { get; } Property Value IReadOnlyList<SubstitutionNode> Methods ToSubstitutionPattern() Converts this concatenation to a substitution pattern string. public override string ToSubstitutionPattern() Returns string The concatenated substitution patterns of all child nodes."
  },
  "api/RegexBuilder.SubstitutionGroupReference.html": {
    "href": "api/RegexBuilder.SubstitutionGroupReference.html",
    "title": "Class SubstitutionGroupReference | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class SubstitutionGroupReference Namespace RegexBuilder Assembly RegexBuilder.dll Represents a substitution that references a captured group by number or name. public class SubstitutionGroupReference : SubstitutionNode Inheritance object SubstitutionNode SubstitutionGroupReference Inherited Members SubstitutionNode.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors SubstitutionGroupReference(int) Initializes a new instance that references a numbered group. public SubstitutionGroupReference(int groupNumber) Parameters groupNumber int The 1-based group number to reference. SubstitutionGroupReference(string) Initializes a new instance that references a named group. public SubstitutionGroupReference(string groupName) Parameters groupName string The name of the group to reference. Properties GroupName Gets the group name, or null if referencing by number. public string GroupName { get; } Property Value string GroupNumber Gets the group number (1-based), or null if referencing by name. public int? GroupNumber { get; } Property Value int? Methods ToSubstitutionPattern() Converts this group reference to a substitution pattern string. public override string ToSubstitutionPattern() Returns string A substitution pattern like \"\\(1\" or \"\\){groupName}\"."
  },
  "api/RegexBuilder.SubstitutionLiteral.html": {
    "href": "api/RegexBuilder.SubstitutionLiteral.html",
    "title": "Class SubstitutionLiteral | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class SubstitutionLiteral Namespace RegexBuilder Assembly RegexBuilder.dll Represents a literal text substitution node. Dollar signs ($) are automatically escaped. public class SubstitutionLiteral : SubstitutionNode Inheritance object SubstitutionNode SubstitutionLiteral Inherited Members SubstitutionNode.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors SubstitutionLiteral(string) Initializes a new instance of SubstitutionLiteral with the specified text. public SubstitutionLiteral(string text) Parameters text string The literal text to include in the substitution pattern. Properties Text Gets the literal text value. public string Text { get; } Property Value string Methods ToSubstitutionPattern() Converts this literal to a substitution pattern string, escaping dollar signs. public override string ToSubstitutionPattern() Returns string The literal text with dollar signs escaped."
  },
  "api/RegexBuilder.SubstitutionNode.html": {
    "href": "api/RegexBuilder.SubstitutionNode.html",
    "title": "Class SubstitutionNode | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class SubstitutionNode Namespace RegexBuilder Assembly RegexBuilder.dll Represents a substitution/replacement pattern node that can be used in regex replacement operations. This is the base class for all substitution pattern nodes. public abstract class SubstitutionNode Inheritance object SubstitutionNode Derived SubstitutionConcatenation SubstitutionGroupReference SubstitutionLiteral SubstitutionSpecialReference Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Methods ToString() Returns the substitution pattern string. public override string ToString() Returns string ToSubstitutionPattern() Converts this node to a substitution pattern string that can be used in Regex.Replace() operations. public abstract string ToSubstitutionPattern() Returns string A string representation of the substitution pattern."
  },
  "api/RegexBuilder.SubstitutionSpecialReference.html": {
    "href": "api/RegexBuilder.SubstitutionSpecialReference.html",
    "title": "Class SubstitutionSpecialReference | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Class SubstitutionSpecialReference Namespace RegexBuilder Assembly RegexBuilder.dll Represents a special substitution reference (like $&, $`, $', $+, $_, $$). public class SubstitutionSpecialReference : SubstitutionNode Inheritance object SubstitutionNode SubstitutionSpecialReference Inherited Members SubstitutionNode.ToString() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors SubstitutionSpecialReference(SubstitutionType) Initializes a new instance with the specified substitution type. public SubstitutionSpecialReference(SubstitutionType type) Parameters type SubstitutionType The type of special substitution. Properties Type Gets the type of special substitution. public SubstitutionType Type { get; } Property Value SubstitutionType Methods ToSubstitutionPattern() Converts this special reference to a substitution pattern string. public override string ToSubstitutionPattern() Returns string A substitution pattern like \"\\(&\", \"\\)`\", \"\\('\", \"\\)+\", \"\\(_\", or \"$\\)\"."
  },
  "api/RegexBuilder.SubstitutionType.html": {
    "href": "api/RegexBuilder.SubstitutionType.html",
    "title": "Enum SubstitutionType | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Enum SubstitutionType Namespace RegexBuilder Assembly RegexBuilder.dll Defines the types of special substitution references. public enum SubstitutionType Fields AfterMatch = 2 Substitutes all text after the match ($'). BeforeMatch = 1 Substitutes all text before the match ($`). EntireInput = 4 Substitutes the entire input string ($_). LastGroup = 3 Substitutes the last group that was captured ($+). LiteralDollar = 5 Substitutes a literal dollar sign ($$). WholeMatch = 0 Substitutes a copy of the whole match ($&)."
  },
  "api/RegexBuilder.html": {
    "href": "api/RegexBuilder.html",
    "title": "Namespace RegexBuilder | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Namespace RegexBuilder Classes CommonPatterns Provides factory methods for commonly used regex patterns. ExtensionMethods PatternBuilder Provides a fluent API for building complex regex patterns with method chaining. RegexBuilder RegexMetaChars RegexNode RegexNodeAlternation RegexNodeBacktrackingSuppression RegexNodeBalancingGroup Represents a balancing group construct in a regular expression. Balancing groups are used to match nested/balanced constructs such as parentheses, XML tags, or code blocks. Supports both two-name form (?<name1-name2>expr) and single-name form (?<name>-expr). RegexNodeCharacterRange RegexNodeCharacterSet RegexNodeComment RegexNodeConcatenation RegexNodeConditionalMatch RegexNodeEscapingLiteral RegexNodeGroup RegexNodeGroupReference RegexNodeInlineOption RegexNodeInlineOptionGrouping Represents an inline option grouping node with support for enabling and disabling options. Generates patterns like (?i:expr), (?im:expr), or (?i-m:expr). RegexNodeLiteral RegexNodeLookAround RegexNodeUnicodeCategory Represents a Unicode category escape sequence in a regular expression. Enables matching of Unicode letters, numbers, and other character categories. Supports both positive matching (\\p{name}) and negative matching (\\P{name}). RegexQuantifier RegexStringEscaper SubstitutionBuilder Factory class for creating substitution/replacement pattern nodes. Use these methods to build replacement patterns for Regex.Replace() operations. SubstitutionConcatenation Represents a concatenation of multiple substitution nodes. SubstitutionGroupReference Represents a substitution that references a captured group by number or name. SubstitutionLiteral Represents a literal text substitution node. Dollar signs ($) are automatically escaped. SubstitutionNode Represents a substitution/replacement pattern node that can be used in regex replacement operations. This is the base class for all substitution pattern nodes. SubstitutionSpecialReference Represents a special substitution reference (like $&, $`, $', $+, $_, $$). Enums RegexLookAround SubstitutionType Defines the types of special substitution references."
  },
  "docs/api-guide.html": {
    "href": "docs/api-guide.html",
    "title": "API Guide | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "API Guide Complete reference for all RegexBuilder.NET9 capabilities. This guide covers both the modern Fluent API and the Classic API, along with advanced features. Table of Contents Core Architecture Fluent API (PatternBuilder) Classic API (RegexBuilder) Quantifiers Substitution Patterns Advanced Features Syntax Mapping Reference Troubleshooting Core Architecture RegexBuilder consists of several key classes: RegexBuilder Purpose: Static factory class for building regex patterns Main Methods: Build(params RegexNode[]) - Builds a Regex from nodes Build(RegexOptions, params RegexNode[]) - Builds with options Pattern() - Returns new PatternBuilder instance Static factory methods for all pattern types PatternBuilder Purpose: Fluent builder for composing patterns with chainable methods Entry Point: var builder = RegexBuilder.Pattern(); Returns: RegexNode via Build() method RegexNode Purpose: Base class for all regex pattern nodes Inheritance Hierarchy: RegexNode (abstract base) RegexNodeLiteral RegexNodeCharacterSet RegexNodeGroup RegexNodeAlternation RegexNodeConcatenation RegexNodeLookAround And many more... RegexQuantifier Purpose: Factory class for creating quantifiers Common Properties: ZeroOrMore → * OneOrMore → + Optional → ? Exactly(n) → {n} Range(min, max) → {min,max} AtLeast(n) → {n,} RegexMetaChars Purpose: Named constants for character classes Constants: WordCharacter → \\w NonwordCharacter → \\W Digit → \\d Nondigit → \\D WhiteSpace → \\s NonwhiteSpace → \\S AnyCharacter → . CommonPatterns Purpose: Pre-built patterns for common scenarios Methods: Email() - Email validation pattern Url() - URL validation pattern SubstitutionBuilder Purpose: Factory class for creating replacement patterns (used with Regex.Replace()) Methods: Group references, special references, literals Fluent API (PatternBuilder) The modern, recommended approach for building patterns. Getting Started // Create a new builder var builder = RegexBuilder.Pattern(); // Chain methods var pattern = builder .Start() .Literal(\"prefix-\") .Digits(3, 5) .End() .Build(); // Convert to Regex var regex = RegexBuilder.Build(pattern); Pattern Methods Literal Text Literal(string text) Adds literal text with automatic escaping. .Literal(\"hello.world\") // → hello\\.world .Literal(\"price: $5\") // → price:\\ \\$5 Digits Digits() - One or more digits (\\d+) Digits(int exact) - Exactly N digits (\\d{n}) Digits(int? min, int? max) - Range of digits .Digits() // \\d+ .Digits(3) // \\d{3} .Digits(2, 5) // \\d{2,5} .Digits(1, null) // \\d+ (one or more) .Digits(0, null) // \\d* (zero or more) Letters Letters() - One or more letters ([a-zA-Z]+) Letters(int exact) - Exactly N letters Letters(int? min, int? max) - Range of letters .Letters() // [a-zA-Z]+ .Letters(2) // [a-zA-Z]{2} .Letters(2, 4) // [a-zA-Z]{2,4} Whitespace Whitespace() - One or more whitespace (\\s+) Whitespace(int exact) - Exactly N whitespace Whitespace(int? min, int? max) - Range of whitespace .Whitespace() // \\s+ .Whitespace(1) // \\s{1} .Whitespace(0, 1) // \\s? Word Characters WordCharacter() - One or more word characters (\\w+) WordCharacter(int exact) - Exactly N word characters WordCharacter(int? min, int? max) - Range of word characters .WordCharacter() // \\w+ .WordCharacter(5) // \\w{5} .WordCharacter(3, 10) // \\w{3,10} Any Character AnyCharacter() - One or more of any character (.+) AnyCharacter(int exact) - Exactly N of any character AnyCharacter(int? min, int? max) - Range of any character .AnyCharacter() // .+ .AnyCharacter(3) // .{3} .AnyCharacter(0, null) // .* Character Sets CharacterSet(string characters) - One or more from set CharacterSet(string characters, int exact) - Exactly N from set CharacterSet(string characters, int? min, int? max) - Range from set .CharacterSet(\"abc\") // [abc]+ .CharacterSet(\"a-z\", 3) // [a-z]{3} .CharacterSet(\"0-9A-F\", 2, 4) // [0-9A-F]{2,4} Anchor Methods Start Start() Adds start-of-line anchor (^). .Start() // ^ End End() Adds end-of-line anchor ($). .End() // $ Grouping Methods Capturing Group Group(Action<PatternBuilder> configure) Creates a capturing group. .Group(g => g.Digits(3)) // (\\d{3}) Non-Capturing Group NonCapturingGroup(Action<PatternBuilder> configure) Creates a non-capturing group. .NonCapturingGroup(g => g.Literal(\"http\").Optional(s => s.Literal(\"s\"))) // (?:https?) Alternation Methods Or with Builder Or(Action<PatternBuilder> configure) Adds an alternative pattern using a builder. .Literal(\"cat\").Or(o => o.Literal(\"dog\")) // cat|dog Or with Node Or(RegexNode node) Adds an alternative pattern using an existing RegexNode. var catNode = RegexBuilder.Literal(\"cat\"); builder.Literal(\"dog\").Or(catNode) // dog|cat Utility Methods Optional Optional(Action<PatternBuilder> configure) Makes a pattern optional (? quantifier). .Optional(o => o.Literal(\"+1\")) // (?:\\+1)? Email Email() Adds the pre-built email pattern. .Email() // Adds CommonPatterns.Email() URL Url() Adds the pre-built URL pattern. .Url() // Adds CommonPatterns.Url() Custom Pattern Pattern(RegexNode node) Adds a custom RegexNode to the builder. var customNode = RegexBuilder.Digit(RegexQuantifier.Exactly(3)); builder.Pattern(customNode) Build Method Build() Converts the built pattern to a RegexNode. var node = builder.Build(); var regex = RegexBuilder.Build(node); Complete Example // Build a phone number pattern var phonePattern = RegexBuilder.Pattern() .Start() .Optional(o => o.Literal(\"+1\").Whitespace(0, 1)) .Group(g => g.Digits(3)) .CharacterSet(\"- .\", 0, 1) .Group(g => g.Digits(3)) .CharacterSet(\"- .\", 0, 1) .Group(g => g.Digits(4)) .End() .Build(); var phoneRegex = RegexBuilder.Build(phonePattern); Console.WriteLine(phoneRegex.IsMatch(\"555-123-4567\")); // True Classic API (RegexBuilder) The traditional, more verbose API with full access to advanced features. Basic Building // Entry point var regex = RegexBuilder.Build(components...); // With options var regex = RegexBuilder.Build( RegexOptions.IgnoreCase | RegexOptions.Compiled, components... ); Literal and Escaping Literal Literal(string text) Escaped literal text. RegexBuilder.Literal(\"hello.world\") // → hello\\.world NonEscapedLiteral NonEscapedLiteral(string pattern) Raw regex pattern (not escaped). RegexBuilder.NonEscapedLiteral(@\"\\d+\") // → \\d+ (raw) ⚠️ Warning: Use with caution. Incorrect patterns can break regex compilation. MetaCharacter MetaCharacter(char metaChar, RegexQuantifier? quantifier = null) Adds a character class metacharacter. RegexBuilder.MetaCharacter(RegexMetaChars.Digit, RegexQuantifier.OneOrMore) // \\d+ Character Classes Digit Digit(RegexQuantifier? quantifier = null) Matches digit characters (\\d). RegexBuilder.Digit() // \\d RegexBuilder.Digit(RegexQuantifier.OneOrMore) // \\d+ RegexBuilder.Digit(RegexQuantifier.Exactly(3)) // \\d{3} NonDigit NonDigit(RegexQuantifier? quantifier = null) Matches non-digit characters (\\D). RegexBuilder.NonDigit(RegexQuantifier.OneOrMore) // \\D+ Whitespace Whitespace(RegexQuantifier? quantifier = null) Matches whitespace characters (\\s). RegexBuilder.Whitespace() // \\s RegexBuilder.Whitespace(RegexQuantifier.ZeroOrMore) // \\s* NonWhitespace NonWhitespace(RegexQuantifier? quantifier = null) Matches non-whitespace characters (\\S). RegexBuilder.NonWhitespace(RegexQuantifier.OneOrMore) // \\S+ WordCharacter WordCharacter(RegexQuantifier? quantifier = null) Matches word characters (\\w). RegexBuilder.WordCharacter() // \\w RegexBuilder.WordCharacter(RegexQuantifier.OneOrMore) // \\w+ NonWordCharacter NonWordCharacter(RegexQuantifier? quantifier = null) Matches non-word characters (\\W). RegexBuilder.NonWordCharacter(RegexQuantifier.OneOrMore) // \\W+ CharacterSet CharacterSet(string characters, RegexQuantifier? quantifier = null) Positive character set ([...]). RegexBuilder.CharacterSet(\"abc\") // [abc] RegexBuilder.CharacterSet(\"a-z\", RegexQuantifier.OneOrMore) // [a-z]+ RegexBuilder.CharacterSet(\"0-9A-F\", RegexQuantifier.Exactly(2)) // [0-9A-F]{2} NegativeCharacterSet NegativeCharacterSet(string characters, RegexQuantifier? quantifier = null) Negative character set ([^...]). RegexBuilder.NegativeCharacterSet(\"abc\") // [^abc] RegexBuilder.NegativeCharacterSet(\"0-9\", RegexQuantifier.OneOrMore) // [^0-9]+ CharacterRange CharacterRange(char fromChar, char toChar, RegexQuantifier? quantifier = null) Character range ([a-z]). RegexBuilder.CharacterRange('a', 'z') // [a-z] RegexBuilder.CharacterRange('A', 'Z', RegexQuantifier.OneOrMore) // [A-Z]+ Anchors LineStart LineStart() Start of line anchor (^). RegexBuilder.LineStart() // ^ LineEnd LineEnd() End of line anchor ($). RegexBuilder.LineEnd() // $ StringStart StringStart() Start of string anchor (\\A). RegexBuilder.StringStart() // \\A StringEnd StringEnd() End of string anchor (\\Z). RegexBuilder.StringEnd() // \\Z StringEndAbsolute StringEndAbsolute() Absolute end of string anchor (\\z). RegexBuilder.StringEndAbsolute() // \\z WordBoundary WordBoundary(RegexQuantifier? quantifier = null) Word boundary anchor (\\b). RegexBuilder.WordBoundary() // \\b NonWordBoundary NonWordBoundary(RegexQuantifier? quantifier = null) Non-word boundary anchor (\\B). RegexBuilder.NonWordBoundary() // \\B MatchPointAnchor MatchPointAnchor(RegexQuantifier? quantifier = null) Match point anchor (\\G). RegexBuilder.MatchPointAnchor() // \\G Grouping and Capturing Group (Named) Group(string groupName, RegexNode matchExpression, RegexQuantifier? quantifier = null) Named capturing group. RegexBuilder.Group(\"area\", RegexBuilder.Digit(RegexQuantifier.Exactly(3))) // (?<area>\\d{3}) Group (Numbered) Group(RegexNode matchExpression, RegexQuantifier? quantifier = null) Numbered capturing group. RegexBuilder.Group(RegexBuilder.Digit(RegexQuantifier.Exactly(3))) // (\\d{3}) GroupApostrophe GroupApostrophe(string groupName, RegexNode matchExpression, RegexQuantifier? quantifier = null) Named capturing group with apostrophe syntax (VBScript compatible). RegexBuilder.GroupApostrophe(\"name\", RegexBuilder.Literal(\"value\")) // (?'name'value) NonCapturingGroup NonCapturingGroup(RegexNode matchExpression, RegexQuantifier? quantifier = null) Non-capturing group. RegexBuilder.NonCapturingGroup( RegexBuilder.Alternate( RegexBuilder.Literal(\"cat\"), RegexBuilder.Literal(\"dog\") ) ) // (?:cat|dog) BalancingGroup BalancingGroup(string pushName, string popName, RegexNode matchExpression, RegexQuantifier? quantifier = null) Two-name balancing group for nested structures. RegexBuilder.BalancingGroup(\"depth\", \"depth\", RegexBuilder.CharacterSet(\"^()\", RegexQuantifier.ZeroOrMore) ) // (?<depth-depth>[^()]*) SimpleBalancingGroup SimpleBalancingGroup(string name, RegexNode matchExpression, RegexQuantifier? quantifier = null) Single-name balancing group. RegexBuilder.SimpleBalancingGroup(\"stack\", RegexBuilder.Literal(\"item\")) // (?<stack>-item) Backreferences GroupReference (Named) GroupReference(string groupName) Reference a named capturing group. RegexBuilder.GroupReference(\"word\") // \\k<word> GroupReference (Numbered) GroupReference(int groupNumber) Reference a numbered capturing group. RegexBuilder.GroupReference(1) // \\1 Lookaround Assertions PositiveLookAhead PositiveLookAhead(RegexNode matchExpression) Positive lookahead ((?=...)). RegexBuilder.PositiveLookAhead(RegexBuilder.Digit()) // (?=\\d) NegativeLookAhead NegativeLookAhead(RegexNode matchExpression) Negative lookahead ((?!...)). RegexBuilder.NegativeLookAhead(RegexBuilder.Digit()) // (?!\\d) PositiveLookBehind PositiveLookBehind(RegexNode matchExpression) Positive lookbehind ((?<=...)). RegexBuilder.PositiveLookBehind(RegexBuilder.Literal(\"$\")) // (?<=\\$) NegativeLookBehind NegativeLookBehind(RegexNode matchExpression) Negative lookbehind ((?<!...)). RegexBuilder.NegativeLookBehind(RegexBuilder.Literal(\"$\")) // (?<!\\$) Alternation Alternate(params RegexNode[] options) Creates alternation between multiple patterns. RegexBuilder.Alternate( RegexBuilder.Literal(\"cat\"), RegexBuilder.Literal(\"dog\"), RegexBuilder.Literal(\"bird\") ) // cat|dog|bird Concatenation Concatenate(params RegexNode[] nodes) Combines multiple patterns in sequence. RegexBuilder.Concatenate( RegexBuilder.Literal(\"prefix-\"), RegexBuilder.Digit(RegexQuantifier.Exactly(3)), RegexBuilder.Literal(\"-suffix\") ) // prefix-\\d{3}-suffix Inline Options InlineOption InlineOption(RegexOptions options) Inline option modifier ((?imnsx-imnsx)). RegexBuilder.InlineOption(RegexOptions.IgnoreCase) // (?i) InlineOptionGrouping InlineOptionGrouping(RegexOptions enabledOptions, RegexNode expression) Inline option grouping ((?i:expr)). RegexBuilder.InlineOptionGrouping( RegexOptions.IgnoreCase, RegexBuilder.Literal(\"abc\") ) // (?i:abc) InlineOptionGrouping(RegexOptions enabledOptions, RegexOptions disabledOptions, RegexNode expression) Inline option grouping with enabled and disabled options ((?i-m:expr)). RegexBuilder.InlineOptionGrouping( RegexOptions.IgnoreCase, RegexOptions.Multiline, RegexBuilder.Literal(\"abc\") ) // (?i-m:abc) Comments Comment(string commentText) Adds an inline comment ((?#comment)). RegexBuilder.Comment(\"This matches digits\") // (?#This matches digits) Unicode Categories UnicodeCategory UnicodeCategory(string categoryName, RegexQuantifier? quantifier = null) Matches Unicode category (\\p{...}). RegexBuilder.UnicodeCategory(\"L\") // \\p{L} RegexBuilder.UnicodeCategory(\"Lu\", RegexQuantifier.OneOrMore) // \\p{Lu}+ RegexBuilder.UnicodeCategory(\"IsCyrillic\") // \\p{IsCyrillic} NegativeUnicodeCategory NegativeUnicodeCategory(string categoryName, RegexQuantifier? quantifier = null) Matches negative Unicode category (\\P{...}). RegexBuilder.NegativeUnicodeCategory(\"L\") // \\P{L} Common Categories: L - All letters Lu - Uppercase letters Ll - Lowercase letters N - All numbers Nd - Decimal digits P - All punctuation IsCyrillic, IsArabic, IsGreek, etc. - Unicode blocks Special Escapes BellCharacter BellCharacter(RegexQuantifier? quantifier = null) Bell character (\\a). RegexBuilder.BellCharacter() // \\a FormFeed FormFeed(RegexQuantifier? quantifier = null) Form feed character (\\f). RegexBuilder.FormFeed() // \\f VerticalTab VerticalTab(RegexQuantifier? quantifier = null) Vertical tab character (\\v). RegexBuilder.VerticalTab() // \\v EscapeCharacter EscapeCharacter(RegexQuantifier? quantifier = null) Escape character (\\e). RegexBuilder.EscapeCharacter() // \\e OctalCharacter OctalCharacter(int octalValue, RegexQuantifier? quantifier = null) Octal character code (\\NNN). RegexBuilder.OctalCharacter(40) // \\040 (space character) Conditional Matching ConditionalMatch(RegexNode conditionExpression, RegexNode trueExpression, RegexNode? falseExpression = null) Conditional matching ((?(condition)yes|no)). RegexBuilder.ConditionalMatch( RegexBuilder.GroupReference(\"prefix\"), RegexBuilder.Literal(\"-suffix\"), RegexBuilder.Literal(\"_suffix\") ) // (?(prefix)-suffix|_suffix) Backtracking Suppression BacktrackingSuppression(RegexNode matchExpression) Atomic grouping/backtracking suppression ((?>...)). RegexBuilder.BacktrackingSuppression( RegexBuilder.Digit(RegexQuantifier.OneOrMore) ) // (?>\\d+) Quantifiers Control how many times a pattern should repeat. Properties RegexQuantifier.ZeroOrMore // * RegexQuantifier.OneOrMore // + RegexQuantifier.Optional // ? Factory Methods RegexQuantifier.Exactly(5) // {5} RegexQuantifier.AtLeast(3) // {3,} RegexQuantifier.Range(2, 5) // {2,5} Lazy Quantifiers var quantifier = RegexQuantifier.OneOrMore; quantifier.Lazy = true; // +? Usage Examples // With Classic API RegexBuilder.Digit(RegexQuantifier.OneOrMore) // \\d+ RegexBuilder.Digit(RegexQuantifier.Exactly(3)) // \\d{3} RegexBuilder.Digit(RegexQuantifier.Range(2, 5)) // \\d{2,5} // With Fluent API .Digits(3) // {3} .Digits(2, 5) // {2,5} .Digits(1, null) // + Substitution Patterns Build replacement patterns for use with Regex.Replace(). Entry Point var replacement = SubstitutionBuilder.Build(components...); string result = regex.Replace(input, replacement); Group References Named Group Group(string groupName) Reference a named group (${name}). SubstitutionBuilder.Group(\"word\") // ${word} Numbered Group Group(int groupNumber) Reference a numbered group ($1). SubstitutionBuilder.Group(1) // $1 Special References WholeMatch() - Entire match ($&) SubstitutionBuilder.WholeMatch() // $& BeforeMatch() - Text before match ($`) SubstitutionBuilder.BeforeMatch() // $` AfterMatch() - Text after match ($') SubstitutionBuilder.AfterMatch() // $' LastCapturedGroup() - Last captured group ($+) SubstitutionBuilder.LastCapturedGroup() // $+ EntireInput() - Entire input string ($_) SubstitutionBuilder.EntireInput() // $_ LiteralDollar() - Literal dollar sign ($$) SubstitutionBuilder.LiteralDollar() // $$ Literal Text Literal(string text) Literal text in replacement (auto-escapes $). SubstitutionBuilder.Literal(\"price: $5\") // price: $$5 Complete Example // Swap two words var pattern = RegexBuilder.Build( RegexBuilder.Group(\"word1\", RegexBuilder.WordCharacter(RegexQuantifier.OneOrMore)), RegexBuilder.Whitespace(), RegexBuilder.Group(\"word2\", RegexBuilder.WordCharacter(RegexQuantifier.OneOrMore)) ); var replacement = SubstitutionBuilder.Build( SubstitutionBuilder.Group(\"word2\"), SubstitutionBuilder.Literal(\" \"), SubstitutionBuilder.Group(\"word1\") ); string result = pattern.Replace(\"hello world\", replacement); // result = \"world hello\" Advanced Features Balancing Groups Match nested/balanced structures like parentheses, XML tags, or code blocks. Syntax: (?<push-pop>expr) or (?<name>-expr) // Match balanced parentheses var balancedParens = RegexBuilder.Build( RegexBuilder.Literal(\"(\"), RegexBuilder.BalancingGroup(\"depth\", \"depth\", RegexBuilder.NegativeCharacterSet(\"()\", RegexQuantifier.ZeroOrMore) ), RegexBuilder.Literal(\")\") ); // Matches: \"()\", \"(text)\", \"((nested))\" Use Cases: Matching balanced parentheses Parsing XML/HTML tags Extracting code blocks Finding nested JSON structures Unicode Category Matching Match characters by Unicode category or block. // Match any letter (any language) var letters = RegexBuilder.UnicodeCategory(\"L\", RegexQuantifier.OneOrMore); // Match Cyrillic text var cyrillic = RegexBuilder.UnicodeCategory(\"IsCyrillic\", RegexQuantifier.OneOrMore); // Match non-Latin characters var nonLatin = RegexBuilder.NegativeUnicodeCategory(\"IsBasicLatin\"); // Test var regex = RegexBuilder.Build(cyrillic); Console.WriteLine(regex.IsMatch(\"Привет\")); // True (Cyrillic) Console.WriteLine(regex.IsMatch(\"Hello\")); // False (Latin) Common Categories: L - All letters Lu - Uppercase letters Ll - Lowercase letters N - Numbers Nd - Decimal digits P - Punctuation S - Symbols Z - Separators Common Blocks: IsBasicLatin IsCyrillic IsArabic IsGreek IsHebrew IsCJKUnifiedIdeographs Inline Option Grouping Apply regex options to specific sub-expressions only. // Case-insensitive match for specific part var pattern = RegexBuilder.Build( RegexBuilder.Literal(\"ID:\"), RegexBuilder.InlineOptionGrouping( RegexOptions.IgnoreCase, RegexBuilder.Literal(\"abc\") ), RegexBuilder.Digit(RegexQuantifier.Exactly(3)) ); // Matches: \"ID:abc123\", \"ID:ABC123\", \"ID:AbC123\" // Doesn't match: \"id:abc123\" (ID is case-sensitive) Available Options: IgnoreCase (i) Multiline (m) Singleline (s) ExplicitCapture (n) IgnorePatternWhitespace (x) Conditional Matching Match different patterns based on whether a condition is true. // Match suffix based on whether prefix group exists var pattern = RegexBuilder.Build( RegexBuilder.Optional(RegexBuilder.Group(\"prefix\", RegexBuilder.Literal(\"PRE\"))), RegexBuilder.Literal(\"-\"), RegexBuilder.ConditionalMatch( RegexBuilder.GroupReference(\"prefix\"), RegexBuilder.Literal(\"SUFFIX\"), RegexBuilder.Literal(\"suffix\") ) ); // Matches: \"PRE-SUFFIX\" or \"-suffix\" Syntax Mapping Reference Quick lookup table for traditional regex → RegexBuilder conversion. Traditional RegexBuilder (Classic) RegexBuilder (Fluent) ^ LineStart() .Start() $ LineEnd() .End() \\d Digit() .Digits() \\d+ Digit(RegexQuantifier.OneOrMore) .Digits(1, null) \\d{3} Digit(RegexQuantifier.Exactly(3)) .Digits(3) or .Digits(3, 3) \\d{2,5} Digit(RegexQuantifier.Range(2, 5)) .Digits(2, 5) \\w WordCharacter() .WordCharacter() \\w+ WordCharacter(RegexQuantifier.OneOrMore) .WordCharacter(1, null) \\s Whitespace() .Whitespace() \\s* Whitespace(RegexQuantifier.ZeroOrMore) .Whitespace(0, null) . MetaCharacter(RegexMetaChars.AnyCharacter) .AnyCharacter() [a-z] CharacterRange('a', 'z') .CharacterSet(\"a-z\") [abc] CharacterSet(\"abc\") .CharacterSet(\"abc\") [^a-z] NegativeCharacterSet(\"a-z\") N/A (use classic) (expr) Group(expr) .Group(g => g...) (?:expr) NonCapturingGroup(expr) .NonCapturingGroup(g => g...) (?<name>expr) Group(\"name\", expr) N/A (use classic) \\1 GroupReference(1) N/A (use classic) \\k<name> GroupReference(\"name\") N/A (use classic) a\\|b Alternate(Literal(\"a\"), Literal(\"b\")) .Literal(\"a\").Or(o => o.Literal(\"b\")) (?=expr) PositiveLookAhead(expr) N/A (use classic) (?!expr) NegativeLookAhead(expr) N/A (use classic) (?<=expr) PositiveLookBehind(expr) N/A (use classic) (?<!expr) NegativeLookBehind(expr) N/A (use classic) (?i:expr) InlineOptionGrouping(RegexOptions.IgnoreCase, expr) N/A (use classic) \\p{L} UnicodeCategory(\"L\") N/A (use classic) \\P{L} NegativeUnicodeCategory(\"L\") N/A (use classic) literal\\.text Literal(\"literal.text\") .Literal(\"literal.text\") Troubleshooting Common Issues Pattern Doesn't Match Expected Input Solution: Test the generated pattern on regex101.com Check for proper escaping of special characters Verify quantifiers are applied correctly Add anchors (Start() / End()) if needed // Debug: Print the generated pattern var pattern = builder.Build(); var regex = RegexBuilder.Build(pattern); Console.WriteLine(regex.ToString()); // See the actual regex Performance is Slow Solution: Cache compiled Regex objects Use RegexOptions.Compiled for hot paths Test with pathological inputs to avoid catastrophic backtracking // ✓ Good: Static, cached, compiled private static readonly Regex EmailRegex = RegexBuilder.Build( RegexOptions.Compiled, CommonPatterns.Email() ); Pattern is Too Verbose Solution: Use Fluent API for simpler patterns Extract reusable components Consider if hand-written regex is better for very simple cases // Extract reusable components public static class MyPatterns { public static RegexNode Identifier() => RegexBuilder.Pattern() .Letters(1) .WordCharacter(0, null) .Build(); } Can't Figure Out Which Method to Use Solution: Check the Syntax Mapping Reference Browse Common Patterns Library for examples Use IDE IntelliSense for method discovery Getting Help GitHub Issues: Report bugs or request features Example Code: Check CustomRegexTests.cs Common Patterns: See Common Patterns Library Getting Started: Review Getting Started Guide Next Steps Getting Started - Learn the basics Common Patterns - Copy-paste ready patterns GitHub Examples - More examples Happy pattern building! \uD83D\uDE80"
  },
  "docs/common-patterns.html": {
    "href": "docs/common-patterns.html",
    "title": "Common Patterns Library | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Common Patterns Library This library provides ready-to-use regex patterns for the most common validation and extraction scenarios. Copy, paste, and customize as needed! How to Use This Library All patterns in this library are designed to be: Copy-paste ready: Use them directly in your code Production-tested: Validated with comprehensive test suites Customizable: Easy to modify for your specific needs Well-documented: Clear examples of what matches and what doesn't Basic Usage using RegexBuilder; // Use a pre-built pattern var emailRegex = RegexBuilder.Build(CommonPatterns.Email()); // Validate input bool isValid = emailRegex.IsMatch(\"user@example.com\"); // With regex options var regex = RegexBuilder.Build( RegexOptions.Compiled | RegexOptions.IgnoreCase, CommonPatterns.Email() ); Quick Reference Pattern Usage Example Match Email CommonPatterns.Email() user@example.com URL CommonPatterns.Url() https://example.com/path US Phone See examples below 555-123-4567 US ZIP Code See examples below 12345 or 12345-6789 IPv4 Address See examples below 192.168.1.1 Date (ISO) See examples below 2025-10-22 Credit Card See examples below 4111-1111-1111-1111 UUID/GUID See examples below 550e8400-e29b-41d4-a716 Email Addresses What It Matches A basic email address with local part, @ symbol, domain, and TLD. Local part: alphanumeric, dots, hyphens, underscores, percent, plus Domain: alphanumeric and hyphens, separated by dots TLD: 2-6 alphabetic characters Pre-Built Pattern using RegexBuilder; // Use the built-in pattern var emailRegex = RegexBuilder.Build(CommonPatterns.Email()); // Test it Console.WriteLine(emailRegex.IsMatch(\"user@example.com\")); // ✓ True Console.WriteLine(emailRegex.IsMatch(\"test.user+tag@domain.co\")); // ✓ True Console.WriteLine(emailRegex.IsMatch(\"invalid.email\")); // ✗ False Console.WriteLine(emailRegex.IsMatch(\"@nodomain.com\")); // ✗ False Examples ✓ Matches: user@example.com first.last@company.co test+tag@domain.org user_name@sub-domain.com ✗ Doesn't Match: invalid.email (no @ symbol) @nodomain.com (no local part) user@ (no domain) user @example.com (space in email) Custom Email Pattern Want more control? Build your own: // Stricter email validation var strictEmail = RegexBuilder.Pattern() .Start() .CharacterSet(\"a-zA-Z0-9\", 1, null) // Must start with alphanumeric .CharacterSet(\"a-zA-Z0-9._%+-\", 0, null) // Followed by allowed chars .Literal(\"@\") .CharacterSet(\"a-zA-Z0-9\", 1, null) // Domain starts with alphanumeric .CharacterSet(\"a-zA-Z0-9.-\", 0, null) // Followed by domain chars .Literal(\".\") .Letters(2, 6) // TLD: 2-6 letters only .End() .Build(); var regex = RegexBuilder.Build(strictEmail); URLs and Web Addresses What It Matches URLs with optional protocol, domain, path, query string, and fragment. Pre-Built Pattern using RegexBuilder; // Use the built-in URL pattern var urlRegex = RegexBuilder.Build(CommonPatterns.Url()); // Test it Console.WriteLine(urlRegex.IsMatch(\"https://github.com/example\")); // ✓ True Console.WriteLine(urlRegex.IsMatch(\"http://example.com/path?q=1\")); // ✓ True Console.WriteLine(urlRegex.IsMatch(\"ftp://files.example.com\")); // ✓ True Console.WriteLine(urlRegex.IsMatch(\"not a url\")); // ✗ False Examples ✓ Matches: https://example.com http://sub.domain.com/path https://example.com/path?query=value&more=data ftp://files.example.com/file.txt https://example.com:8080/path ✗ Doesn't Match: not a url htp://typo.com (invalid protocol) example (no protocol or domain structure) Custom URL Pattern with Capturing Groups // Extract URL components var urlPattern = RegexBuilder.Build( RegexBuilder.Group(\"protocol\", RegexBuilder.CharacterSet(\"a-z\", RegexQuantifier.OneOrMore) ), RegexBuilder.Literal(\"://\"), RegexBuilder.Group(\"domain\", RegexBuilder.CharacterSet(\"a-zA-Z0-9.-\", RegexQuantifier.OneOrMore) ), RegexBuilder.Group(\"path\", RegexBuilder.CharacterSet(\"/a-zA-Z0-9._~:?#@!$&'()*+,;=%-\", RegexQuantifier.ZeroOrMore) ) ); var match = urlPattern.Match(\"https://example.com/path?q=1\"); if (match.Success) { Console.WriteLine($\"Protocol: {match.Groups[\"protocol\"].Value}\"); // https Console.WriteLine($\"Domain: {match.Groups[\"domain\"].Value}\"); // example.com Console.WriteLine($\"Path: {match.Groups[\"path\"].Value}\"); // /path?q=1 } Phone Numbers US Phone Numbers Matches various US phone number formats with optional country code. // Flexible US phone format var phonePattern = RegexBuilder.Pattern() .Optional(o => o.Literal(\"+1\").Optional(sep => sep.CharacterSet(\"- \"))) .Group(g => g.Digits(3)) // Area code .Optional(o => o.CharacterSet(\"- .\")) // Separator .Group(g => g.Digits(3)) // Prefix .Optional(o => o.CharacterSet(\"- .\")) // Separator .Group(g => g.Digits(4)) // Line number .Build(); var phoneRegex = RegexBuilder.Build(phonePattern); // Test it Console.WriteLine(phoneRegex.IsMatch(\"555-123-4567\")); // ✓ True Console.WriteLine(phoneRegex.IsMatch(\"+1-555-123-4567\")); // ✓ True Console.WriteLine(phoneRegex.IsMatch(\"5551234567\")); // ✓ True Console.WriteLine(phoneRegex.IsMatch(\"555.123.4567\")); // ✓ True Console.WriteLine(phoneRegex.IsMatch(\"123-45-6789\")); // ✗ False (not phone format) ✓ Matches: 555-123-4567 +1-555-123-4567 5551234567 555.123.4567 (555) 123-4567 (with parentheses variant - needs adjustment) ✗ Doesn't Match: 12-345-6789 (invalid area code format) 555-12-34567 (wrong digit grouping) Phone with Parentheses // Format: (555) 123-4567 var phoneWithParens = RegexBuilder.Build( RegexBuilder.Optional(RegexBuilder.Literal(\"+1\").Concatenate( RegexBuilder.MetaCharacter(RegexMetaChars.WhiteSpace, RegexQuantifier.Optional) )), RegexBuilder.Literal(\"(\"), RegexBuilder.Digit(RegexQuantifier.Exactly(3)), RegexBuilder.Literal(\")\"), RegexBuilder.MetaCharacter(RegexMetaChars.WhiteSpace, RegexQuantifier.Optional), RegexBuilder.Digit(RegexQuantifier.Exactly(3)), RegexBuilder.CharacterSet(\"- .\", RegexQuantifier.Optional), RegexBuilder.Digit(RegexQuantifier.Exactly(4)) ); Postal Codes US ZIP Codes // Matches: 12345 or 12345-6789 var zipPattern = RegexBuilder.Pattern() .Start() .Digits(5) .Optional(o => o.Literal(\"-\").Digits(4)) .End() .Build(); var zipRegex = RegexBuilder.Build(zipPattern); Console.WriteLine(zipRegex.IsMatch(\"12345\")); // ✓ True Console.WriteLine(zipRegex.IsMatch(\"12345-6789\")); // ✓ True Console.WriteLine(zipRegex.IsMatch(\"1234\")); // ✗ False (too short) Canadian Postal Codes // Format: A1A 1A1 var canadianPostal = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.CharacterSet(\"A-Z\", RegexQuantifier.Exactly(1)), RegexBuilder.Digit(RegexQuantifier.Exactly(1)), RegexBuilder.CharacterSet(\"A-Z\", RegexQuantifier.Exactly(1)), RegexBuilder.MetaCharacter(RegexMetaChars.WhiteSpace, RegexQuantifier.Optional), RegexBuilder.Digit(RegexQuantifier.Exactly(1)), RegexBuilder.CharacterSet(\"A-Z\", RegexQuantifier.Exactly(1)), RegexBuilder.Digit(RegexQuantifier.Exactly(1)), RegexBuilder.LineEnd() ); ✓ Matches: K1A 0B1 M5V3A8 (without space) UK Postcodes // Format: SW1A 1AA var ukPostcode = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.CharacterSet(\"A-Z\", new RegexQuantifier(1, 2)), RegexBuilder.Digit(RegexQuantifier.Exactly(1)), RegexBuilder.CharacterSet(\"A-Z0-9\", RegexQuantifier.Optional), RegexBuilder.MetaCharacter(RegexMetaChars.WhiteSpace, RegexQuantifier.Optional), RegexBuilder.Digit(RegexQuantifier.Exactly(1)), RegexBuilder.CharacterSet(\"A-Z\", RegexQuantifier.Exactly(2)), RegexBuilder.LineEnd() ); Credit Cards ⚠️ Security Warning: Never log, store, or transmit credit card numbers in plain text. Use these patterns for validation only, and always follow PCI DSS compliance standards. Visa // Visa: Starts with 4, 13-16 digits total var visaPattern = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Literal(\"4\"), RegexBuilder.Digit(new RegexQuantifier(12, 15)), RegexBuilder.LineEnd() ); Console.WriteLine(visaPattern.IsMatch(\"4111111111111111\")); // ✓ True (test card) Mastercard // Mastercard: Starts with 51-55 or 2221-2720, 16 digits total var mastercardPattern = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Alternate( RegexBuilder.Concatenate( RegexBuilder.Literal(\"5\"), RegexBuilder.CharacterSet(\"1-5\", RegexQuantifier.Exactly(1)) ), RegexBuilder.Concatenate( RegexBuilder.Literal(\"22\"), RegexBuilder.CharacterSet(\"2-9\", RegexQuantifier.Exactly(1)), RegexBuilder.Digit(RegexQuantifier.Exactly(1)) ) ), RegexBuilder.Digit(RegexQuantifier.Exactly(12)), RegexBuilder.LineEnd() ); American Express // Amex: Starts with 34 or 37, 15 digits total var amexPattern = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Literal(\"3\"), RegexBuilder.CharacterSet(\"47\", RegexQuantifier.Exactly(1)), RegexBuilder.Digit(RegexQuantifier.Exactly(13)), RegexBuilder.LineEnd() ); Generic Card with Separators // Matches: 4111-1111-1111-1111 or 4111 1111 1111 1111 var cardWithSeparators = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Digit(RegexQuantifier.Exactly(4)), RegexBuilder.CharacterSet(\"- \", RegexQuantifier.Optional), RegexBuilder.Digit(RegexQuantifier.Exactly(4)), RegexBuilder.CharacterSet(\"- \", RegexQuantifier.Optional), RegexBuilder.Digit(RegexQuantifier.Exactly(4)), RegexBuilder.CharacterSet(\"- \", RegexQuantifier.Optional), RegexBuilder.Digit(RegexQuantifier.Exactly(4)), RegexBuilder.LineEnd() ); IP Addresses IPv4 // Basic IPv4 pattern (simplified, doesn't validate ranges) var ipv4Pattern = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Digit(new RegexQuantifier(1, 3)), RegexBuilder.Literal(\".\"), RegexBuilder.Digit(new RegexQuantifier(1, 3)), RegexBuilder.Literal(\".\"), RegexBuilder.Digit(new RegexQuantifier(1, 3)), RegexBuilder.Literal(\".\"), RegexBuilder.Digit(new RegexQuantifier(1, 3)), RegexBuilder.LineEnd() ); Console.WriteLine(ipv4Pattern.IsMatch(\"192.168.1.1\")); // ✓ True Console.WriteLine(ipv4Pattern.IsMatch(\"10.0.0.1\")); // ✓ True Console.WriteLine(ipv4Pattern.IsMatch(\"999.999.999.999\")); // ✓ True (pattern doesn't validate range) Note: This pattern validates the format but doesn't check if octets are in the valid range (0-255). For stricter validation, use additional logic. IPv4 with Range Validation (Classic API) // More accurate IPv4 validation var octet = RegexBuilder.Alternate( RegexBuilder.Concatenate( RegexBuilder.Literal(\"25\"), RegexBuilder.CharacterSet(\"0-5\", RegexQuantifier.Exactly(1)) ), RegexBuilder.Concatenate( RegexBuilder.Literal(\"2\"), RegexBuilder.CharacterSet(\"0-4\", RegexQuantifier.Exactly(1)), RegexBuilder.Digit(RegexQuantifier.Exactly(1)) ), RegexBuilder.Concatenate( RegexBuilder.CharacterSet(\"01\", RegexQuantifier.Optional), RegexBuilder.Digit(new RegexQuantifier(1, 2)) ) ); var ipv4Strict = RegexBuilder.Build( RegexBuilder.LineStart(), octet, RegexBuilder.Literal(\".\"), octet, RegexBuilder.Literal(\".\"), octet, RegexBuilder.Literal(\".\"), octet, RegexBuilder.LineEnd() ); Console.WriteLine(ipv4Strict.IsMatch(\"192.168.1.1\")); // ✓ True Console.WriteLine(ipv4Strict.IsMatch(\"255.255.255.255\")); // ✓ True Console.WriteLine(ipv4Strict.IsMatch(\"256.1.1.1\")); // ✗ False Dates and Time ISO 8601 Date (YYYY-MM-DD) var isoDate = RegexBuilder.Pattern() .Start() .Digits(4) // Year .Literal(\"-\") .Digits(2) // Month .Literal(\"-\") .Digits(2) // Day .End() .Build(); var dateRegex = RegexBuilder.Build(isoDate); Console.WriteLine(dateRegex.IsMatch(\"2025-10-22\")); // ✓ True Console.WriteLine(dateRegex.IsMatch(\"2025-1-1\")); // ✗ False (needs zero-padding) US Date (MM/DD/YYYY) var usDate = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Digit(new RegexQuantifier(1, 2)), RegexBuilder.Literal(\"/\"), RegexBuilder.Digit(new RegexQuantifier(1, 2)), RegexBuilder.Literal(\"/\"), RegexBuilder.Digit(RegexQuantifier.Exactly(4)), RegexBuilder.LineEnd() ); Console.WriteLine(usDate.IsMatch(\"10/22/2025\")); // ✓ True Console.WriteLine(usDate.IsMatch(\"1/1/2025\")); // ✓ True Time (HH:MM or HH:MM:SS) var time24h = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Digit(RegexQuantifier.Exactly(2)), RegexBuilder.Literal(\":\"), RegexBuilder.Digit(RegexQuantifier.Exactly(2)), RegexBuilder.Optional( RegexBuilder.Concatenate( RegexBuilder.Literal(\":\"), RegexBuilder.Digit(RegexQuantifier.Exactly(2)) ) ), RegexBuilder.LineEnd() ); Console.WriteLine(time24h.IsMatch(\"14:30\")); // ✓ True Console.WriteLine(time24h.IsMatch(\"14:30:45\")); // ✓ True Identifiers and Codes UUID/GUID // Format: 550e8400-e29b-41d4-a716-446655440000 var uuidPattern = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.CharacterSet(\"a-fA-F0-9\", RegexQuantifier.Exactly(8)), RegexBuilder.Literal(\"-\"), RegexBuilder.CharacterSet(\"a-fA-F0-9\", RegexQuantifier.Exactly(4)), RegexBuilder.Literal(\"-\"), RegexBuilder.CharacterSet(\"a-fA-F0-9\", RegexQuantifier.Exactly(4)), RegexBuilder.Literal(\"-\"), RegexBuilder.CharacterSet(\"a-fA-F0-9\", RegexQuantifier.Exactly(4)), RegexBuilder.Literal(\"-\"), RegexBuilder.CharacterSet(\"a-fA-F0-9\", RegexQuantifier.Exactly(12)), RegexBuilder.LineEnd() ); Console.WriteLine(uuidPattern.IsMatch(\"550e8400-e29b-41d4-a716-446655440000\")); // ✓ True Hexadecimal String // Matches hex strings with optional 0x prefix var hexPattern = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Optional(RegexBuilder.Literal(\"0x\")), RegexBuilder.CharacterSet(\"a-fA-F0-9\", RegexQuantifier.OneOrMore), RegexBuilder.LineEnd() ); Console.WriteLine(hexPattern.IsMatch(\"0x1A2B3C\")); // ✓ True Console.WriteLine(hexPattern.IsMatch(\"DEADBEEF\")); // ✓ True Social Security Number (US) ⚠️ Privacy Warning: SSNs are highly sensitive. Never log, display, or store them without proper encryption and compliance measures. // Format: 123-45-6789 var ssnPattern = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Digit(RegexQuantifier.Exactly(3)), RegexBuilder.Literal(\"-\"), RegexBuilder.Digit(RegexQuantifier.Exactly(2)), RegexBuilder.Literal(\"-\"), RegexBuilder.Digit(RegexQuantifier.Exactly(4)), RegexBuilder.LineEnd() ); File Paths and Names Windows File Path // Format: C:\\Users\\Name\\file.txt var windowsPath = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.CharacterSet(\"A-Z\", RegexQuantifier.Exactly(1)), RegexBuilder.Literal(\":\"), RegexBuilder.Concatenate( RegexBuilder.NonEscapedLiteral(\"\\\\\\\\\"), RegexBuilder.CharacterSet(@\"a-zA-Z0-9_\\- .\", RegexQuantifier.OneOrMore) ), RegexBuilder.LineEnd() ); Unix File Path // Format: /home/user/file.txt var unixPath = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.Literal(\"/\"), RegexBuilder.CharacterSet(\"a-zA-Z0-9_/.-\", RegexQuantifier.OneOrMore), RegexBuilder.LineEnd() ); File Extension // Extract file extension var fileExtPattern = RegexBuilder.Build( RegexBuilder.MetaCharacter(RegexMetaChars.AnyCharacter, RegexQuantifier.ZeroOrMore), RegexBuilder.Literal(\".\"), RegexBuilder.Group(\"extension\", RegexBuilder.CharacterSet(\"a-zA-Z0-9\", RegexQuantifier.OneOrMore) ), RegexBuilder.LineEnd() ); var match = fileExtPattern.Match(\"document.pdf\"); Console.WriteLine(match.Groups[\"extension\"].Value); // pdf Customization Tips Making Patterns More Strict // Original: Allows any separator .Optional(o => o.CharacterSet(\"- .\")) // Stricter: Only allows dash .Literal(\"-\") Making Patterns More Lenient // Original: Requires exact format .Digits(3).Literal(\"-\").Digits(3).Literal(\"-\").Digits(4) // More lenient: Optional separators .Digits(3).Optional(o => o.CharacterSet(\"- .\")).Digits(3).Optional(o => o.CharacterSet(\"- .\")).Digits(4) Adding Anchors // Without anchors: Matches anywhere in string var pattern = RegexBuilder.Pattern().Email().Build(); // With anchors: Must match entire string var strictPattern = RegexBuilder.Pattern() .Start() .Email() .End() .Build(); Performance Considerations Cache Compiled Patterns // ✓ Good: Static, compiled, reusable private static readonly Regex EmailRegex = RegexBuilder.Build( RegexOptions.Compiled, CommonPatterns.Email() ); // ✗ Avoid: Rebuilding every time public bool Validate(string input) { var regex = RegexBuilder.Build(CommonPatterns.Email()); return regex.IsMatch(input); } Use Appropriate Options // For case-insensitive matching var regex = RegexBuilder.Build( RegexOptions.Compiled | RegexOptions.IgnoreCase, pattern ); // For multiline text var regex = RegexBuilder.Build( RegexOptions.Compiled | RegexOptions.Multiline, pattern ); Next Steps Getting Started - Learn the basics of RegexBuilder API Guide - Explore advanced features and complete API reference GitHub Examples - See more real-world examples Happy pattern matching! \uD83C\uDFAF"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Getting Started Welcome to RegexBuilder.NET9! This guide will help you create your first human-readable regular expressions in just 5 minutes. Why RegexBuilder? Traditional regex patterns like (?:https?://)?(?:[a-z0-9.-]+)(?::[0-9]+)? are powerful but cryptic. RegexBuilder lets you write the same pattern as readable, maintainable C# code: var pattern = RegexBuilder.Pattern() .Optional(o => o.Literal(\"http\").Optional(s => s.Literal(\"s\")).Literal(\"://\")) .CharacterSet(\"a-z0-9.-\", 1, null) .Optional(o => o.Literal(\":\").Digits(1, null)) .Build(); Installation Install RegexBuilder.NET9 from NuGet: Using .NET CLI dotnet add package RegexBuilder.NET9 --version 1.1.1 Using PackageReference in .csproj <PackageReference Include=\"RegexBuilder.NET9\" Version=\"1.1.1\" /> Requirements .NET 9.0 or later Your First Pattern (Fluent API) Let's build a simple email validator using the modern Fluent API (recommended for most use cases): using RegexBuilder; // Build an email validation pattern var emailPattern = RegexBuilder.Pattern() .Start() // ^ anchor .CharacterSet(\"a-zA-Z0-9._%+-\", 1, null) // local part: one or more allowed chars .Literal(\"@\") // @ symbol .CharacterSet(\"a-zA-Z0-9.-\", 1, null) // domain: one or more allowed chars .Literal(\".\") // literal dot .Letters(2, 6) // TLD: 2-6 letters .End() // $ anchor .Build(); // Convert to a compiled Regex var emailRegex = RegexBuilder.Build(emailPattern); // Test it Console.WriteLine(emailRegex.IsMatch(\"user@example.com\")); // True Console.WriteLine(emailRegex.IsMatch(\"invalid.email\")); // False Console.WriteLine(emailRegex.IsMatch(\"test@domain.co.uk\")); // False (needs adjustment for multiple dots) How It Works RegexBuilder.Pattern() - Creates a new fluent pattern builder .Start() - Adds the ^ anchor (start of line) .CharacterSet(...) - Creates a character class [...] .Literal(...) - Adds literal text (auto-escaped) .Letters(min, max) - Adds [a-zA-Z] with quantifiers .End() - Adds the $ anchor (end of line) .Build() - Converts to a RegexNode RegexBuilder.Build(node) - Compiles to a .NET Regex object Generated Pattern The code above generates this regex pattern: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$ Much more readable in code form! Your First Pattern (Classic API) The same email pattern using the Classic API (more verbose but offers advanced features): using RegexBuilder; var emailRegex = RegexBuilder.Build( RegexBuilder.LineStart(), RegexBuilder.CharacterSet(\"a-zA-Z0-9._%+-\", RegexQuantifier.OneOrMore), RegexBuilder.Literal(\"@\"), RegexBuilder.CharacterSet(\"a-zA-Z0-9.-\", RegexQuantifier.OneOrMore), RegexBuilder.Literal(\".\"), RegexBuilder.CharacterSet(\"a-zA-Z\", new RegexQuantifier(2, 6)), RegexBuilder.LineEnd() ); // Test it Console.WriteLine(emailRegex.IsMatch(\"user@example.com\")); // True Console.WriteLine(emailRegex.IsMatch(\"invalid.email\")); // False When to Use Each API Fluent API Classic API ✓ Simpler, more intuitive ✓ Full access to advanced features ✓ Chainable methods ✓ Backreferences and group references ✓ Best for common patterns ✓ Lookaround assertions ✓ Less verbose ✓ Conditional matching ✓ Unicode categories ✓ Inline option grouping Recommendation: Start with the Fluent API. Switch to Classic API when you need advanced features. Common Patterns Library Don't want to build patterns from scratch? Use the CommonPatterns library for instant productivity: using RegexBuilder; // Email validation (pre-built) var emailRegex = RegexBuilder.Build(CommonPatterns.Email()); // URL validation (pre-built) var urlRegex = RegexBuilder.Build(CommonPatterns.Url()); // Test them Console.WriteLine(emailRegex.IsMatch(\"user@example.com\")); // True Console.WriteLine(urlRegex.IsMatch(\"https://github.com/example\")); // True See the Common Patterns Library for a complete list of pre-built patterns. More Examples Phone Number Pattern // Matches: 555-123-4567, +1-555-123-4567, 5551234567 var phonePattern = RegexBuilder.Pattern() .Optional(o => o.Literal(\"+1\").Optional(sep => sep.CharacterSet(\"- \"))) .Digits(3, 3) // Area code .Optional(o => o.CharacterSet(\"- \")) .Digits(3, 3) // Prefix .Optional(o => o.CharacterSet(\"- \")) .Digits(4, 4) // Line number .Build(); var phoneRegex = RegexBuilder.Build(phonePattern); Console.WriteLine(phoneRegex.IsMatch(\"555-123-4567\")); // True Console.WriteLine(phoneRegex.IsMatch(\"+1-555-123-4567\")); // True Console.WriteLine(phoneRegex.IsMatch(\"5551234567\")); // True ID Pattern with Alternation // Matches: ID-123 or CODE-AB var idPattern = RegexBuilder.Pattern() .Start() .Literal(\"ID-\") .Digits(3, 5) .Or(o => o.Literal(\"CODE-\").Letters(2, 4)) .End() .Build(); var idRegex = RegexBuilder.Build(idPattern); Console.WriteLine(idRegex.IsMatch(\"ID-123\")); // True Console.WriteLine(idRegex.IsMatch(\"CODE-AB\")); // True Console.WriteLine(idRegex.IsMatch(\"INVALID\")); // False Capturing Groups // Extract parts of a version string var versionPattern = RegexBuilder.Build( RegexBuilder.Group(\"major\", RegexBuilder.Digit(RegexQuantifier.OneOrMore)), RegexBuilder.Literal(\".\"), RegexBuilder.Group(\"minor\", RegexBuilder.Digit(RegexQuantifier.OneOrMore)), RegexBuilder.Literal(\".\"), RegexBuilder.Group(\"patch\", RegexBuilder.Digit(RegexQuantifier.OneOrMore)) ); var match = versionPattern.Match(\"1.2.3\"); if (match.Success) { Console.WriteLine($\"Major: {match.Groups[\"major\"].Value}\"); // Major: 1 Console.WriteLine($\"Minor: {match.Groups[\"minor\"].Value}\"); // Minor: 2 Console.WriteLine($\"Patch: {match.Groups[\"patch\"].Value}\"); // Patch: 3 } Basic Concepts Pattern Composition RegexBuilder treats patterns as composable building blocks. You can: Build small patterns and combine them Reuse patterns across multiple regex expressions Test patterns independently before combining // Build reusable components var digitPart = RegexBuilder.Pattern().Digits(3).Build(); var separator = RegexBuilder.Literal(\"-\"); // Combine them var ssn = RegexBuilder.Build( digitPart, separator, RegexBuilder.Pattern().Digits(2).Build(), separator, RegexBuilder.Pattern().Digits(4).Build() ); // Matches: 123-45-6789 Quantifiers Control how many times a pattern repeats: // Fluent API quantifiers .Digits(3, 3) // Exactly 3 digits: \\d{3} .Digits(1, null) // One or more digits: \\d+ .Digits(0, null) // Zero or more digits: \\d* .Digits(2, 5) // 2 to 5 digits: \\d{2,5} // Classic API quantifiers RegexQuantifier.Exactly(3) // {3} RegexQuantifier.OneOrMore // + RegexQuantifier.ZeroOrMore // * RegexQuantifier.Optional // ? RegexQuantifier.Range(2, 5) // {2,5} RegexQuantifier.AtLeast(2) // {2,} Anchors Ensure patterns match at specific positions: // Fluent API .Start() // ^ - Start of line .End() // $ - End of line // Classic API RegexBuilder.LineStart() // ^ RegexBuilder.LineEnd() // $ RegexBuilder.StringStart() // \\A RegexBuilder.StringEnd() // \\Z RegexBuilder.WordBoundary() // \\b Character Classes Match specific types of characters: // Fluent API .Digits() // \\d .Letters() // [a-zA-Z] .Whitespace() // \\s .WordCharacter() // \\w .AnyCharacter() // . .CharacterSet(\"abc\") // [abc] // Classic API RegexBuilder.Digit() // \\d RegexBuilder.Whitespace() // \\s RegexBuilder.WordCharacter() // \\w RegexBuilder.CharacterSet(\"a-z\") // [a-z] RegexBuilder.NegativeCharacterSet(\"a-z\") // [^a-z] Performance Tips Cache Compiled Regex Objects // ✓ Good: Cache and reuse private static readonly Regex EmailRegex = RegexBuilder.Build( RegexOptions.Compiled, CommonPatterns.Email() ); public bool ValidateEmail(string input) => EmailRegex.IsMatch(input); // ✗ Avoid: Rebuilding on every call public bool ValidateEmail(string input) { var regex = RegexBuilder.Build(CommonPatterns.Email()); // Overhead! return regex.IsMatch(input); } Use RegexOptions.Compiled for Hot Paths // For frequently-used patterns, use Compiled option var regex = RegexBuilder.Build( RegexOptions.Compiled | RegexOptions.IgnoreCase, CommonPatterns.Email() ); Next Steps Now that you understand the basics, explore more advanced features: Common Patterns Library - Pre-built patterns for email, URL, phone, and more API Guide - Complete reference for all RegexBuilder capabilities GitHub Examples - Real-world examples and test cases Advanced Features to Explore Lookaround Assertions - Match patterns based on what comes before/after Backreferences - Reference previously captured groups Balancing Groups - Match nested structures (parentheses, XML tags) Unicode Categories - Match international characters Substitution Patterns - Advanced Regex.Replace() operations Getting Help GitHub Issues: Report bugs or request features Example Code: Check out CustomRegexTests.cs API Documentation: Explore the auto-generated API reference Happy pattern building! \uD83C\uDF89"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "Introduction Welcome to RegexBuilder.NET9 RegexBuilder.NET9 is a C# library that lets you build .NET regular expressions using human-readable, maintainable code instead of cryptic regex syntax. The Problem Traditional regex patterns are powerful but notoriously difficult to read and maintain: ^(?:https?://)?(?:[a-z0-9.-]+)(?::[0-9]+)?(?:/[^?\\s]*)?(?:\\?[^\\s]*)?$ Quick—can you tell what this pattern matches? How about explaining it to a colleague? The Solution With RegexBuilder, write the same pattern as self-documenting C# code: var urlPattern = RegexBuilder.Pattern() .Start() .Optional(o => o .Literal(\"http\") .Optional(s => s.Literal(\"s\")) .Literal(\"://\") ) .CharacterSet(\"a-z0-9.-\", 1, null) .Optional(o => o.Literal(\":\").Digits(1, null)) .Optional(o => o.Literal(\"/\").CharacterSet(\"^?\\\\s\", 0, null)) .Optional(o => o.Literal(\"?\").CharacterSet(\"^\\\\s\", 0, null)) .End() .Build(); var urlRegex = RegexBuilder.Build(urlPattern); Now it's clear: this matches a URL with optional protocol, optional port, optional path, and optional query string. When to Use RegexBuilder RegexBuilder is ideal when: ✅ Complexity matters: Your regex patterns are complex enough that readability is important ✅ Team maintenance: Multiple developers need to understand and modify patterns ✅ Dynamic patterns: You're building patterns programmatically with conditional logic ✅ Clarity over brevity: You value self-documenting code RegexBuilder may not be necessary when: ❌ Simple patterns: Trivial patterns like \\d{3} are fine as-is ❌ One-time use: Quick throwaway scripts where you won't revisit the code ❌ Performance-critical: Extreme performance requirements where construction overhead matters (though runtime is identical) Key Features \uD83C\uDFAF Two APIs for Different Needs Fluent API (Modern): Chainable, intuitive, perfect for common patterns RegexBuilder.Pattern() .Start() .Email() .End() .Build(); Classic API (Powerful): Full access to advanced regex features RegexBuilder.Build( RegexBuilder.PositiveLookAhead(RegexBuilder.Digit()), RegexBuilder.BalancingGroup(\"depth\", \"depth\", expr) ); \uD83D\uDCDA Common Patterns Library Pre-built, production-ready patterns for instant productivity: var emailRegex = RegexBuilder.Build(CommonPatterns.Email()); var urlRegex = RegexBuilder.Build(CommonPatterns.Url()); \uD83D\uDD27 Advanced Features Balancing Groups: Match nested structures (parentheses, XML tags) Unicode Categories: Match international text by character category Lookaround Assertions: Lookahead and lookbehind patterns Substitution Patterns: Advanced Regex.Replace() operations Inline Options: Apply options to specific sub-expressions ✨ Developer Experience IntelliSense Support: Full code completion and documentation Compile-Time Safety: Catch errors before runtime Composable Patterns: Build complex patterns from reusable components Automatic Escaping: No more forgetting to escape special characters How It Works RegexBuilder uses the Builder Pattern to construct regex patterns: Build patterns using fluent methods or static factory methods Compose patterns by combining smaller patterns into larger ones Compile to Regex - Generate a standard .NET Regex object Identical runtime performance - No overhead after construction // 1. Build a pattern var phonePattern = RegexBuilder.Pattern() .Digits(3) .Literal(\"-\") .Digits(3) .Literal(\"-\") .Digits(4) .Build(); // 2. Compile to Regex var phoneRegex = RegexBuilder.Build( RegexOptions.Compiled, // Optional: compile for performance phonePattern ); // 3. Use like any .NET Regex bool isValid = phoneRegex.IsMatch(\"555-123-4567\"); Project History RegexBuilder.NET9 is a fork of the original regex-builder by Yuriy Guts, updated and enhanced for .NET 9 with: ✨ .NET 9 support ✨ Fluent API (PatternBuilder) ✨ Common Patterns Library ✨ Unicode category matching ✨ Balancing groups ✨ Inline option grouping ✨ Substitution patterns ✨ Enhanced convenience methods Quick Start Ready to get started? Jump right in: Getting Started - Installation and first examples (5 minutes) Common Patterns - Copy-paste ready patterns for common needs API Guide - Complete reference for all features Installation Install via NuGet: dotnet add package RegexBuilder.NET9 --version 1.1.1 Or add to your .csproj: <PackageReference Include=\"RegexBuilder.NET9\" Version=\"1.1.1\" /> Quick Example Let's validate an email address: using RegexBuilder; // Build the pattern var emailPattern = RegexBuilder.Pattern() .Start() .CharacterSet(\"a-zA-Z0-9._%+-\", 1, null) .Literal(\"@\") .CharacterSet(\"a-zA-Z0-9.-\", 1, null) .Literal(\".\") .Letters(2, 6) .End() .Build(); // Compile to Regex var emailRegex = RegexBuilder.Build(emailPattern); // Use it Console.WriteLine(emailRegex.IsMatch(\"user@example.com\")); // True Console.WriteLine(emailRegex.IsMatch(\"invalid.email\")); // False Philosophy RegexBuilder follows these principles: Readability First Code is read far more often than it's written. RegexBuilder optimizes for clarity: // Traditional: What does this do? new Regex(@\"(?<=\\$)\\d+\\.\\d{2}\") // RegexBuilder: Crystal clear RegexBuilder.Build( RegexBuilder.PositiveLookBehind(RegexBuilder.Literal(\"$\")), RegexBuilder.Digit(RegexQuantifier.OneOrMore), RegexBuilder.Literal(\".\"), RegexBuilder.Digit(RegexQuantifier.Exactly(2)) ) // Matches: Dollar amount after $ sign (e.g., \"5.99\" in \"$5.99\") Composability Build complex patterns from simple, reusable components: // Define reusable components var areaCode = RegexBuilder.Pattern().Digits(3).Build(); var exchange = RegexBuilder.Pattern().Digits(3).Build(); var lineNumber = RegexBuilder.Pattern().Digits(4).Build(); // Compose them var phonePattern = RegexBuilder.Build( areaCode, RegexBuilder.Literal(\"-\"), exchange, RegexBuilder.Literal(\"-\"), lineNumber ); Safety Let the compiler catch errors before runtime: // Compile-time error: Method doesn't exist .Dgits(3) // Typo caught by IDE! // Automatic escaping prevents subtle bugs .Literal(\"price: $5.99\") // Correctly escapes special chars Community and Support GitHub: somenoe/RegexBuilder.NET9 Issues: Report bugs or request features Examples: See real-world examples License This project is licensed under the MIT License. See LICENSE for details. Ready to write better regex? Get Started →"
  },
  "index.html": {
    "href": "index.html",
    "title": "RegexBuilder.NET9 | RegexBuilder.NET9 - Fluent Regex Builder",
    "summary": "RegexBuilder.NET9 Welcome to the official documentation site for RegexBuilder.NET9 — a fluent, human-readable C# library for building .NET regular expressions. Quick links Getting Started — Install and create your first pattern in 5 minutes Common Patterns — Copy-paste ready production patterns (email, URL, phone, etc.) API Guide — Full reference for the Fluent and Classic APIs GitHub Repository — Source code, issues, and contribution guidelines NuGet Package — Official NuGet package page for RegexBuilder.NET9 Install Install via NuGet: dotnet add package RegexBuilder.NET9 --version 1.1.1 Or add to your project file: <PackageReference Include=\"RegexBuilder.NET9\" Version=\"1.1.1\" /> Why use RegexBuilder? Readable, maintainable regex expressed as C# code Fluent API for fast pattern composition Classic API for advanced scenarios (lookarounds, balancing groups, substitutions) Pre-built patterns to save time Contribute Contributions, bug reports, and feature requests are welcome. See the project on GitHub."
  }
}